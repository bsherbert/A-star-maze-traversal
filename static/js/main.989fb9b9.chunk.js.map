{"version":3,"sources":["MazeSolver/Cell/Cell.jsx","MazeSolver/PriorityQueue.jsx","MazeSolver/DataCell.jsx","MazeSolver/Maze/Maze.jsx","MazeSolver/MazeSolver.jsx","App.js","serviceWorker.js","index.js"],"names":["Cell","this","props","value","className","onMouseDown","onMouseEnter","onMouseUp","Component","QElement","element","priority","PriorityQueue","items","qElement","contain","i","length","gVal","splice","push","isEmpty","shift","console","log","position","DataCell","status","fVal","hVal","treePointer","searchValue","blockedMemory","Array","numRows","fill","Maze","state","cells","previousMaze","previousStart","previousGoal","action","mouseIsDown","startLocation","goalLocation","inProgress","showExtraAnimations","updateNeeded","handleResetClick","setState","slice","handleMouseDown","buttonClicked","s","Math","floor","random","r","q","dataCells","currentCell","alg","pointer","upTo","path","pt","Number","MAX_SAFE_INTEGER","abs","below","right","above","left","oList","cList","counter","visitedCells","dequeue","enqueue","contains","front","undefined","totalTime","Promise","resolve","setTimeout","clCells","finalPathTaken","finalpt","checkNeighbors","updateWalls","newOList","newCList","computePath","alert","animateClosedList","debugProjectedPath","animateProjectedPath","showProjectedPath","animateTraversal","resetBoardStates","animateFinalPath","establishMaze","forwardAStar","handleMouseEnter","handleMouseUp","maze","row","j","key","renderCell","onClick","handleButtonClick","handleRandomizeClick","handleClearClick","handleAnimationsClick","handleDebugClick","handleFasClick","MazeSolver","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.989fb9b9.chunk.js","sourcesContent":["import React, {Component} from 'react';\r\nimport './Cell.css';\r\n\r\nexport default class Cell extends Component{\r\n    render(){\r\n        switch(this.props.value){\r\n            case \"c\":\r\n                return( \r\n                    <button \r\n                        className=\"cell open-cell\"\r\n                        onMouseDown= {() => this.props.onMouseDown()}\r\n                        onMouseEnter= {() => this.props.onMouseEnter()}\r\n                        onMouseUp= {() => this.props.onMouseUp()}\r\n                    >\r\n                        \r\n                    </button>\r\n                );\r\n            case \"w\":\r\n                return( \r\n                    <button \r\n                        className=\"cell wall-cell\"\r\n                        onMouseDown= {() => this.props.onMouseDown()}\r\n                        onMouseEnter= {() => this.props.onMouseEnter()}\r\n                        onMouseUp= {() => this.props.onMouseUp()}\r\n                    >\r\n                    </button>\r\n                );\r\n            case \"ws\":\r\n                return( \r\n                    <button \r\n                        className=\"cell wall-cell-seen\"\r\n                        onMouseDown= {() => this.props.onMouseDown()}\r\n                        onMouseEnter= {() => this.props.onMouseEnter()}\r\n                        onMouseUp= {() => this.props.onMouseUp()}\r\n                    >\r\n                    </button>\r\n                );\r\n            case \"s\":\r\n                return( \r\n                    <button \r\n                        className=\"cell start-cell\"\r\n                        onMouseDown= {() => this.props.onMouseDown()}\r\n                        onMouseEnter= {() => this.props.onMouseEnter()}\r\n                        onMouseUp= {() => this.props.onMouseUp()}\r\n                    >\r\n\r\n                    </button>\r\n                );\r\n            case \"g\":\r\n                return( \r\n                    <button \r\n                        className=\"cell goal-cell\"\r\n                        onMouseDown= {() => this.props.onMouseDown()}\r\n                        onMouseEnter= {() => this.props.onMouseEnter()}\r\n                        onMouseUp= {() => this.props.onMouseUp()}\r\n                    >\r\n\r\n                    </button>\r\n                );\r\n        \r\n            case \"cl\":\r\n                return( \r\n                    <button \r\n                        className=\"cell cList-cell\"\r\n                        onMouseDown= {() => this.props.onMouseDown()}\r\n                        onMouseEnter= {() => this.props.onMouseEnter()}\r\n                        onMouseUp= {() => this.props.onMouseUp()}\r\n                    >\r\n\r\n                    </button>\r\n                );    \r\n            case \"clw\":\r\n                return( \r\n                    <button \r\n                        className=\"cell cList-cell-w\"\r\n                        onMouseDown= {() => this.props.onMouseDown()}\r\n                        onMouseEnter= {() => this.props.onMouseEnter()}\r\n                        onMouseUp= {() => this.props.onMouseUp()}\r\n                    >\r\n\r\n                    </button>\r\n                );\r\n            case \"pp\":\r\n                return( \r\n                    <button \r\n                        className=\"cell projected-path-cell\"\r\n                        onMouseDown= {() => this.props.onMouseDown()}\r\n                        onMouseEnter= {() => this.props.onMouseEnter()}\r\n                        onMouseUp= {() => this.props.onMouseUp()}\r\n                    >\r\n\r\n                    </button>\r\n                ); \r\n            case \"ppw\":\r\n                return(\r\n                    <button \r\n                        className=\"cell projected-path-cell-w\"\r\n                        onMouseDown= {() => this.props.onMouseDown()}\r\n                        onMouseEnter= {() => this.props.onMouseEnter()}\r\n                        onMouseUp= {() => this.props.onMouseUp()}\r\n                    >\r\n\r\n                    </button>\r\n                );\r\n            case \"t\":\r\n                return( \r\n                    <button \r\n                        className=\"cell traversed-cell\"\r\n                        onMouseDown= {() => this.props.onMouseDown()}\r\n                        onMouseEnter= {() => this.props.onMouseEnter()}\r\n                        onMouseUp= {() => this.props.onMouseUp()}\r\n                    >\r\n                        {\"J\"}\r\n                    </button>\r\n                );\r\n            case \"tg\":\r\n                return( \r\n                    \r\n                    <button \r\n                        className=\"cell traversed-cell-goal\"\r\n                        onMouseDown= {() => this.props.onMouseDown()}\r\n                        onMouseEnter= {() => this.props.onMouseEnter()}\r\n                        onMouseUp= {() => this.props.onMouseUp()}\r\n                    >\r\n                        {\"J\"}\r\n                    </button>\r\n                );\r\n            case \"fp\":\r\n                return(\r\n                    \r\n                    <button \r\n                        className=\"cell final-path-cell\"\r\n                        onMouseDown= {() => this.props.onMouseDown()}\r\n                        onMouseEnter= {() => this.props.onMouseEnter()}\r\n                        onMouseUp= {() => this.props.onMouseUp()}\r\n                    >\r\n                       <div className=\"texture\"></div>\r\n                    </button>\r\n                ); \r\n            default:\r\n                return( \r\n                    <button \r\n                        className=\"cell open-cell\"\r\n                        onMouseDown= {() => this.props.onMouseDown()}\r\n                        onMouseEnter= {() => this.props.onMouseEnter()}\r\n                        onMouseUp= {() => this.props.onMouseUp()}\r\n                    >\r\n\r\n                    </button>\r\n                );\r\n        }\r\n    }\r\n}","//code for priority queue from geeksforgeeks.org/implementation-priority-queue-javascript/\r\n\r\n// User defined class \r\n// to store element and its priority \r\nexport class QElement { \r\n    constructor(element, priority) \r\n    { \r\n        this.element = element; \r\n        this.priority = priority; \r\n    } \r\n} \r\n  \r\n// PriorityQueue class \r\nexport default class PriorityQueue { \r\n  \r\n    // An array is used to implement priority \r\n    constructor()  \r\n    { \r\n        this.items = []; \r\n    } \r\n\r\n    // enqueue function to add element \r\n    // to the queue as per priority \r\n    enqueue(element, priority) \r\n    { \r\n        // creating object from queue element \r\n        var qElement = new QElement(element, priority); \r\n        var contain = false; \r\n    \r\n        // iterating through the entire \r\n        // item array to add element at the \r\n        // correct location of the Queue \r\n        for (var i = 0; i < this.items.length; i++) { \r\n            if(this.items[i].priority === qElement.priority){\r\n                if(this.items[i].element.gVal > qElement.element.gVal){\r\n                    continue;\r\n                }\r\n                else if(this.items[i].element.gVal === qElement.element.gVal){\r\n                    this.items.splice(i+1,0,qElement);\r\n                    contain = true;\r\n                    break;\r\n                }\r\n                else{\r\n                    this.items.splice(i,0,qElement);\r\n                    contain = true;\r\n                    break;\r\n                }\r\n            }\r\n            else if (this.items[i].priority > qElement.priority) { \r\n                // Once the correct location is found it is \r\n                // enqueued \r\n                this.items.splice(i, 0, qElement); \r\n                contain = true; \r\n                break; \r\n            } \r\n        } \r\n    \r\n        // if the element have the highest priority \r\n        // it is added at the end of the queue \r\n        if (!contain) { \r\n            this.items.push(qElement); \r\n        } \r\n    } \r\n\r\n    // dequeue method to remove \r\n    // element from the queue \r\n    dequeue() \r\n    { \r\n        // return the dequeued element \r\n        // and remove it. \r\n        // if the queue is empty \r\n        // returns Underflow \r\n        if (this.isEmpty()) \r\n            return \"Underflow\"; \r\n        return this.items.shift(); \r\n    } \r\n\r\n    // front function \r\n    front() \r\n    { \r\n        // returns the highest priority element \r\n        // in the Priority queue without removing it. \r\n        if (this.isEmpty()) \r\n            return \"No elements in Queue\"; \r\n        return this.items[0]; \r\n    } \r\n\r\n    // rear function \r\n    rear() \r\n    { \r\n        // returns the lowest priorty \r\n        // element of the queue \r\n        if (this.isEmpty()) \r\n            return \"No elements in Queue\"; \r\n        return this.items[this.items.length - 1]; \r\n    } \r\n\r\n    // isEmpty function \r\n    isEmpty() \r\n    { \r\n        // return true if the queue is empty. \r\n        return this.items.length === 0; \r\n    } \r\n\r\n    //check if provided object is present in queue\r\n    contains(element){\r\n        for (var i = 0; i < this.items.length; i++){\r\n            if(this.items[i].element === element)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    printList(){\r\n        for(let i=0; i<this.items.length; i++){\r\n            console.log(\"index \" + i + \" position \" + this.items[i].element.position);\r\n        }\r\n    }\r\n} \r\n\r\n","export default class DataCell{\r\n\r\n    constructor(status){\r\n        this.status = status;\r\n        this.gVal = null;\r\n        this.fVal = null;\r\n        this.hVal = null;\r\n        this.position = null;\r\n        this.treePointer = null;\r\n        this.searchValue = 0;\r\n    }\r\n\r\n}","import React, {Component} from 'react';\r\nimport './Maze.css';\r\nimport Cell from '../Cell/Cell'\r\nimport PriorityQueue from '../PriorityQueue';\r\nimport DataCell from '../DataCell';\r\n\r\n//global variables\r\nconst numColumns = 50;\r\nconst numRows = 30;\r\nconst mazeSize = numRows*numColumns;\r\nconst clWaitTime = 25;\r\nconst ppWaitTime = 50;\r\nconst travWaitTime = 100;\r\nconst finalWaitTime = 75;\r\nvar blockedMemory = Array(mazeSize).fill(false);\r\n\r\n\r\nexport default class Maze extends Component{ \r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            //initial layout of cells in maze\r\n            cells: Array(mazeSize).fill(\"c\"),\r\n            previousMaze: Array(mazeSize).fill(\"c\"),\r\n            previousStart: null,\r\n            previousGoal: null,\r\n            //track buttons for placing maze items\r\n            action: \"c\",\r\n            //tracks if mouse is down for smoother UX\r\n            mouseIsDown: false,\r\n            startLocation: null,\r\n            goalLocation: null,\r\n\r\n            inProgress: false,\r\n            showExtraAnimations: false,\r\n            updateNeeded: false,\r\n        };\r\n    }\r\n\r\n    \r\n    //adjusts selected cell based on last button pressed\r\n    async handleMouseDown(i){\r\n        if(this.state.inProgress)\r\n            return;\r\n        if(this.state.updateNeeded){\r\n            await this.handleResetClick();\r\n        }\r\n        this.setState({mouseIsDown: true});\r\n        var cells = this.state.cells.slice();\r\n        \r\n\r\n        //reset start/goal location if overwritten\r\n\r\n        if(this.state.cells[i] === \"s\"){\r\n            this.setState({startLocation: null});\r\n        }\r\n        else if(this.state.cells[i] === \"g\"){\r\n            this.setState({goalLocation: null});\r\n        }\r\n         \r\n        //allow only one start/goal\r\n        if(this.state.action === \"s\"){\r\n            if(this.state.startLocation !== null){\r\n                cells[this.state.startLocation] = \"c\";\r\n            }\r\n            this.setState({startLocation: i});\r\n            cells[i] = \"s\";           \r\n        }\r\n        else if(this.state.action === \"g\"){\r\n            if(this.state.goalLocation !== null){\r\n                cells[this.state.goalLocation] = \"c\";\r\n            }\r\n            this.setState({goalLocation: i});\r\n            cells[i] = \"g\";\r\n        }\r\n        \r\n\r\n        //create duplicate maze to maintain immutability\r\n        cells[i] = this.state.action;\r\n        \r\n        this.setState({cells: cells});\r\n\r\n    }\r\n\r\n    //adjusts selected cell based on last button pressed\r\n    handleMouseEnter(i){\r\n        if(this.state.mouseIsDown){\r\n            this.handleMouseDown(i);\r\n        }\r\n    }\r\n\r\n    //adjusts selected cell based on last button pressed\r\n    handleMouseUp(i){\r\n        this.setState({mouseIsDown: false});\r\n    }\r\n\r\n    //adjusts the action variable based on the last button pressed\r\n    handleButtonClick(buttonClicked){\r\n        this.setState({\r\n            action: buttonClicked,\r\n        });\r\n    }\r\n\r\n    //create a random maze layout\r\n    handleRandomizeClick(){  \r\n        if(this.state.inProgress)\r\n            return;\r\n        const cells = this.state.cells.slice();\r\n        //pick a random starting point\r\n        let s = Math.floor(Math.random() * mazeSize);\r\n        //console.log(s);\r\n\r\n        //pick a random goal that is not the same as the start point\r\n        let r = s;\r\n        while(r === s){\r\n            r = Math.floor(Math.random() * mazeSize)\r\n        }\r\n\r\n        //give every non start/goal cell a 30% chance to be marked as a wall\r\n        for(let i=0; i<mazeSize; i++){\r\n            let q = Math.floor(Math.random() * 101);\r\n            if(q <= 30){\r\n                cells[i] = \"w\";\r\n            }\r\n            else{\r\n                cells[i] = \"c\";\r\n            }    \r\n        }\r\n        cells[s] = \"s\";\r\n        cells[r] = \"g\"; \r\n        this.setState({cells: cells,\r\n                        startLocation: s,\r\n                        goalLocation: r,\r\n                        updateNeeded: false});\r\n\r\n    }\r\n\r\n    //clear the maze to be all empty cells\r\n    handleClearClick(){\r\n        if(this.state.inProgress){\r\n            return;\r\n        }\r\n        this.setState({cells: Array(mazeSize).fill(\"c\"),\r\n                        startLocation: null,\r\n                        goalLocation: null,\r\n                        updateNeeded: false});\r\n    }\r\n\r\n    handleAnimationsClick(){\r\n        if(this.state.inProgress){\r\n            return;\r\n        }\r\n        this.setState({showExtraAnimations: !this.state.showExtraAnimations});\r\n    }\r\n\r\n    //shows logs for debugging\r\n    handleDebugClick(){\r\n        console.log(\"debug pressed\");\r\n        console.log(\"current action is \" + this.state.action);\r\n        console.log(\"current state is \" + this.state.cells);\r\n        console.log(\"start location is \" + this.state.startLocation);\r\n        console.log(\"goal location is \" + this.state.goalLocation);\r\n        console.log(\"mouse pressed is \" + this.state.mouseIsDown);\r\n        console.log(\"updateNeeded: \" + this.state.updateNeeded);\r\n        \r\n\r\n        //display blocked memory\r\n        /*\r\n        for(let i=0; i<mazeSize; i++){\r\n            console.log(\"blocked \" + i + \": \" + blockedMemory[i]);\r\n        }\r\n*/\r\n    }\r\n\r\n    debugMaze(dataCells){\r\n        for(let i=0; i<mazeSize; i++){\r\n            console.log(\"index: \" + i);\r\n            console.log(\"position: \" + dataCells[i].position);\r\n            console.log(\"status: \" + dataCells[i].status);\r\n            console.log(\"gVal: \" + dataCells[i].gVal);\r\n            console.log(\"fVal: \" + dataCells[i].fVal);\r\n            console.log(\"hVal: \" + dataCells[i].hVal);\r\n            console.log(\"searchVal: \" + dataCells[i].searchValue);\r\n            console.log(\"treePointer: \" + dataCells[i].treePointer);\r\n        }\r\n    }\r\n\r\n    debugProjectedPath(dataCells, currentCell, alg){\r\n        var pointer = dataCells[this.state.goalLocation];\r\n        var upTo = currentCell;\r\n        var path = [];\r\n        var pt = 0;\r\n\r\n        if(alg === \"f\"){\r\n            console.log(\"Projected Path: \");\r\n            console.log(\"{\" + currentCell.status + \",\" + currentCell.position + \"} \");\r\n            path[pt] = currentCell;\r\n            pt++;\r\n\r\n            while(upTo !== dataCells[this.state.goalLocation]){\r\n                while(pointer.treePointer !== upTo){\r\n                    pointer = pointer.treePointer;\r\n                }\r\n                console.log(\"{\" + pointer.status + \",\" + pointer.position + \"} \");\r\n                path[pt] = pointer;\r\n                pt++;\r\n\r\n                upTo = pointer;\r\n                pointer = dataCells[this.state.goalLocation];\r\n            }\r\n        }\r\n\r\n    }\r\n    \r\n    //alg parameter adjusts setup based on \"f\", \"b\", or \"a\" for forward, backward, and adaptive a*, respectively\r\n    //a cells (x,y) location in maze based on id is (id%numColumns, id/numColumns)\r\n    establishMaze(alg, dataCells){\r\n        //reset the agent's memory of the maze before re-running the algorithm  \r\n        blockedMemory.fill(false);\r\n        \r\n        //fill array of dataCells based on Cell status\r\n        for(let i=0; i<mazeSize; i++){\r\n            dataCells[i] = new DataCell(this.state.cells[i]);\r\n            dataCells[i].position = i;\r\n        }\r\n        \r\n        //fill dataCells with f,g,h,search values\r\n        for(let i=0; i<mazeSize; i++){\r\n            dataCells[i].gVal = Number.MAX_SAFE_INTEGER;\r\n            dataCells[i].fVal = Number.MAX_SAFE_INTEGER;\r\n            if(alg === \"f\"){\r\n                dataCells[i].hVal = Math.abs(i%numColumns - this.state.goalLocation%numColumns) + Math.abs(Math.floor(i/numColumns) - Math.floor(this.state.goalLocation/numColumns));\r\n            }\r\n            //this.debugMaze(dataCells);\r\n        }\r\n    }\r\n\r\n    //looks at cells adjacent to the current cell, sets any that are walls to true in blockedMemory \r\n    checkNeighbors(dataCells, currentCell){\r\n\r\n        var below = currentCell.position + numColumns;\r\n        var right = currentCell.position + 1;\r\n        var above = currentCell.position - numColumns;\r\n        var left = currentCell.position - 1;\r\n        //check below\r\n        //console.log(\"current position: \" + currentCell.position);\r\n        //console.log(\"below: \" + below);\r\n        //console.log(\"right: \" + right);\r\n        //console.log(\"above: \" + above);\r\n        //console.log(\"left: \" + left);\r\n        \r\n        //console.log(\"in check neighbors\");\r\n        if(below < mazeSize){\r\n            //console.log(\"1\");\r\n            if(dataCells[below].status === \"w\" || dataCells[below].status === \"clw\" || dataCells[below].status === \"ppw\" || dataCells[below].status === \"ws\"){\r\n                //console.log(\"2\");\r\n\r\n                blockedMemory[below] = true;\r\n            }\r\n        }\r\n        //check right\r\n        if(Math.floor(currentCell.position/numColumns) === Math.floor(right/numColumns)){\r\n            //console.log(\"3\");\r\n            if(dataCells[right].status === \"w\" || dataCells[right].status === \"clw\" || dataCells[right].status === \"ppw\" || dataCells[right].status === \"ws\"){\r\n                //console.log(\"4\");\r\n                blockedMemory[right] = true;\r\n            }\r\n        }\r\n        //check above\r\n        if(above >= 0){\r\n            //console.log(\"5\");\r\n            if(dataCells[above].status === \"w\" || dataCells[above].status === \"clw\" || dataCells[above].status === \"ppw\" || dataCells[above].status === \"ws\"){\r\n                //console.log(\"6\");\r\n                blockedMemory[above] = true;\r\n            }\r\n        }\r\n        //check left\r\n        if(Math.floor(currentCell.position/numColumns) === Math.floor(left/numColumns)){\r\n            //console.log(\"7\");\r\n            if(dataCells[left].status === \"w\" || dataCells[left].status === \"clw\" || dataCells[left].status === \"ppw\" || dataCells[left].status === \"ws\"){\r\n                //console.log(\"8\");\r\n                blockedMemory[left] = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    //computes the projected path of a single iteration of any A* algorithm\r\n    computePath(oList, cList, dataCells, counter){\r\n        //track visited cells in order (for animation)\r\n        var visitedCells = [];\r\n        //var counter = 0;\r\n\r\n        //determine starting position\r\n        var currentCell = oList.dequeue().element;\r\n\r\n        //console.log(\"starting compute path on \" + currentCell.position);\r\n        //while g value of goal is greater than g value of current cell\r\n        while(dataCells[this.state.goalLocation].gVal > currentCell.gVal){\r\n            //add current position to closed list\r\n            cList.enqueue(currentCell, currentCell.fVal);\r\n            //console.log(currentCell.position + \" added to closed list\");\r\n            //cList.printList();\r\n            \r\n            //track visited cells\r\n            visitedCells.push(currentCell);\r\n            //counter++;\r\n            //console.log(currentCell.position + \" set to cl\");\r\n            //this.handleDebugClick();\r\n\r\n\r\n            //for every non wall neighbor of currentCell\r\n            var below = currentCell.position + numColumns;\r\n            var right = currentCell.position + 1;\r\n            var above = currentCell.position - numColumns;\r\n            var left = currentCell.position - 1;\r\n\r\n            //if bottom neighbor is inbounds\r\n            if(below < mazeSize){\r\n                //if neighbor is not blocked, not start, and has a search value less than counter\r\n                if(!blockedMemory[below] && !cList.contains(dataCells[below]) && !oList.contains(dataCells[below])){\r\n                    if(dataCells[below].searchValue < counter){\r\n                        //set g and search value\r\n                        dataCells[below].gVal = Number.MAX_SAFE_INTEGER;\r\n                        dataCells[below].searchValue = counter;\r\n                    }\r\n                    if(dataCells[below].gVal > currentCell.gVal + 1){\r\n                        dataCells[below].gVal = currentCell.gVal + 1;\r\n                    }\r\n                    dataCells[below].treePointer = currentCell;\r\n                    //if cell below is in oList, remove\r\n                    if(oList.front().element === dataCells[below]){\r\n                        oList.dequeue();\r\n                    }\r\n                    //update f value, add below cell to open list\r\n                    dataCells[below].fVal = dataCells[below].gVal + dataCells[below].hVal;\r\n                    oList.enqueue(dataCells[below], dataCells[below].fVal);\r\n\r\n                    //look at this line in eclipse project if issues, not using a temp Cell to do things\r\n                    //console.log(\"(below) {\" + dataCells[below].position + \"} added to olist\");\r\n                }\r\n            }\r\n            //if right neighbor is inbounds\r\n            if(Math.floor(currentCell.position/numColumns) === Math.floor(right/numColumns)){\r\n                //if neighbor is not blocked, not start, and has a search value less than counter\r\n                if(!blockedMemory[right] && !cList.contains(dataCells[right]) && !oList.contains(dataCells[right])){\r\n                    if(dataCells[right].searchValue < counter){\r\n                        //set g and search value\r\n                        dataCells[right].gVal = Number.MAX_SAFE_INTEGER;\r\n                        dataCells[right].searchValue = counter;\r\n                    }\r\n                    if(dataCells[right].gVal > currentCell.gVal + 1){\r\n                        dataCells[right].gVal = currentCell.gVal + 1;\r\n                    }\r\n                    dataCells[right].treePointer = currentCell;\r\n                    //if cell right is in oList, remove\r\n                    if(oList.front().element === dataCells[right]){\r\n                        oList.dequeue();\r\n                    }\r\n                    dataCells[right].fVal = dataCells[right].gVal + dataCells[right].hVal;\r\n                    //update f value, add right cell to open list\r\n                    oList.enqueue(dataCells[right], dataCells[right].fVal);\r\n\r\n                    //look at this line in eclipse project if issues, not using a temp Cell to do things\r\n                    //console.log(\"(right) {\" + dataCells[right].position + \"} added to olist\");\r\n                }\r\n            }\r\n            //if above neighbor is inbounds\r\n            if(above >= 0){\r\n                //if neighbor is not blocked, not start, and has a search value less than counter\r\n                if(!blockedMemory[above] && !cList.contains(dataCells[above]) && !oList.contains(dataCells[above])){\r\n                    if(dataCells[above].searchValue < counter){\r\n                        //set g and search value\r\n                        dataCells[above].gVal = Number.MAX_SAFE_INTEGER;\r\n                        dataCells[above].searchValue = counter;\r\n                    }\r\n                    if(dataCells[above].gVal > currentCell.gVal + 1){\r\n                        dataCells[above].gVal = currentCell.gVal + 1;\r\n                    }\r\n                    dataCells[above].treePointer = currentCell;\r\n                    //if cell above is in oList, remove\r\n                    if(oList.front().element === dataCells[above]){\r\n                        oList.dequeue();\r\n                    }\r\n                    dataCells[above].fVal = dataCells[above].gVal + dataCells[above].hVal;\r\n                    //update f value, add above cell to open list\r\n                    oList.enqueue(dataCells[above], dataCells[above].fVal);\r\n\r\n                    //look at this line in eclipse project if issues, not using a temp Cell to do things\r\n                    //console.log(\"(above) {\" + dataCells[above].position + \"} added to olist\");\r\n                }\r\n            }\r\n            //if left neighbor is inbounds\r\n            if(Math.floor(currentCell.position/numColumns) === Math.floor(left/numColumns)){\r\n                //if neighbor is not blocked, not start, and has a search value less than counter\r\n                if(!blockedMemory[left] && !cList.contains(dataCells[left]) && !oList.contains(dataCells[left])){\r\n                    if(dataCells[left].searchValue < counter){\r\n                        //set g and search value\r\n                        dataCells[left].gVal = Number.MAX_SAFE_INTEGER;\r\n                        dataCells[left].searchValue = counter;\r\n                    }\r\n                    if(dataCells[left].gVal > currentCell.gVal + 1){\r\n                        dataCells[left].gVal = currentCell.gVal + 1;\r\n                    }\r\n                    dataCells[left].treePointer = currentCell;\r\n                    //if cell left is in oList, remove\r\n                    if(oList.front().element === dataCells[left]){\r\n                        oList.dequeue();\r\n                    }\r\n                    dataCells[left].fVal = dataCells[left].gVal + dataCells[left].hVal;\r\n                    //update f value, add left cell to open list\r\n                    oList.enqueue(dataCells[left], dataCells[left].fVal);\r\n\r\n                    //look at this line in eclipse project if issues, not using a temp Cell to do things\r\n                    //console.log(\"(left) {\" + dataCells[left].position + \"} added to olist\");\r\n                }\r\n            }\r\n\r\n            //move on to next cell in queue\r\n            //oList.printList();\r\n            currentCell = oList.dequeue().element;\r\n            //console.log(\"last dequeue'd element: \" + currentCell.position);\r\n            //console.log(\"goal at end: \" + dataCells[this.state.goalLocation].position);\r\n            //when out of cells, return\r\n            if(currentCell === undefined){\r\n                return visitedCells;\r\n            }\r\n\r\n        }\r\n        //console.log(\"shoulde probably be returning closed list here too\");\r\n        //might not do anything...\r\n        oList.enqueue(currentCell, currentCell.fVal);\r\n\r\n        //makes the goal in the open list\r\n        /*\r\n        //a***************************************\r\n        cells = this.state.cells.slice();\r\n        cells[currentCell.position] = \"ol\";\r\n        this.setState({cells: cells});\r\n        //a***************************************\r\n        */\r\n        return visitedCells;\r\n\r\n    }\r\n\r\n    async animateClosedList(visitedCells){\r\n        const totalTime = (visitedCells.length * clWaitTime) + clWaitTime\r\n        return new Promise(resolve =>{\r\n            for(let i=0; i<visitedCells.length; i++){\r\n                setTimeout(()=> {\r\n                    const currentCell = visitedCells[i];\r\n                    //a***************************************\r\n                    const cells = this.state.cells.slice();\r\n                    //console.log(\"STATUS IS \" + currentCell.status);\r\n                    if(currentCell.status === \"c\"){\r\n                        cells[currentCell.position] = \"cl\";\r\n                        //this.state.cells[currentCell.position] = \"cl\";\r\n                        currentCell.status = \"cl\"\r\n                    }\r\n                    else if(currentCell.status ===\"w\" || currentCell.status === \"ws\"){\r\n                        cells[currentCell.position] = \"clw\"\r\n                        //this.state.cells[currentCell.position] = \"clw\";\r\n                        currentCell.status = \"clw\";\r\n                    }\r\n                    this.setState({cells: cells});\r\n                    //a***************************************\r\n                    //console.log(\"hi :)\");\r\n                }, clWaitTime * i);\r\n            }\r\n            setTimeout(()=>{\r\n                resolve();\r\n                }, totalTime);\r\n        });\r\n    }\r\n\r\n    async animateProjectedPath(path){\r\n            const totalTime = (path.length * ppWaitTime) + ppWaitTime;\r\n            //console.log(\"total pp time = \" + totalTime);\r\n            return new Promise(resolve =>{\r\n                for(let i=0; i<path.length; i++){\r\n                    setTimeout(()=>{\r\n                        //add cases for cl, clw, g, a\r\n                        const cells = this.state.cells.slice();\r\n                        if(path[i].status === \"c\" || path[i].status === \"cl\"){\r\n                            cells[path[i].position] = \"pp\";\r\n                            //this.state.cells[path[i].position] = \"pp\";\r\n                            path[i].status = \"pp\";\r\n                        }\r\n                        else if(path[i].status === \"w\" || path[i].status === \"ws\" || path[i].status === \"clw\"){\r\n                            cells[path[i].position] = \"ppw\";\r\n                            //this.state.cells[path[i].position] = \"ppw\";\r\n                            path[i].status = \"ppw\";\r\n                        }\r\n                        this.setState({cells: cells});\r\n                    }, ppWaitTime * i);\r\n                }\r\n                setTimeout(() => {\r\n                    resolve();\r\n                    }, totalTime);\r\n            });        \r\n    }\r\n\r\n    showProjectedPath(path){\r\n        const cells = this.state.cells.slice();\r\n        for(let i=0; i<path.length; i++){\r\n            if(path[i].status === \"c\" || path[i].status === \"cl\"){\r\n                cells[path[i].position] = \"pp\";\r\n                //this.state.cells[path[i].position] = \"pp\";\r\n                path[i].status = \"pp\";\r\n            }\r\n            else if(path[i].status === \"w\" || path[i].status === \"ws\" || path[i].status === \"clw\"){\r\n                cells[path[i].position] = \"ppw\";\r\n                //this.state.cells[path[i].position] = \"ppw\";\r\n                path[i].status = \"ppw\";\r\n            }\r\n        }\r\n        this.setState({cells: cells});\r\n    }\r\n\r\n    async animateTraversal(path){\r\n        const totalTime = (path.length * travWaitTime) + travWaitTime;\r\n        //console.log(\"total t time = \" + totalTime);\r\n        return new Promise(resolve =>{\r\n            for(let i=0; i<path.length; i++){\r\n                setTimeout(()=>{\r\n                    const cells = this.state.cells.slice();\r\n                    if(path[i].status !== \"g\"){\r\n                        cells[path[i].position] = \"t\";\r\n                        //this.state.cells[path[i].position] = \"t\";\r\n                        path[i].status = \"t\";\r\n                    }\r\n                    if(i>0){\r\n                        if(path[i-1].position === this.state.startLocation){\r\n                            cells[path[i-1].position] = \"s\";\r\n                            //this.state.cells[path[i-1].position] = \"s\";\r\n                            path[i-1].status = \"s\";\r\n                        }\r\n                        else{\r\n                            cells[path[i-1].position] = \"pp\";\r\n                            //this.state.cells[path[i-1].position] = \"pp\";\r\n                            path[i-1].status = \"pp\";\r\n                        }\r\n                    } \r\n                    //console.log(\"status is: \" + path[i].status)\r\n\r\n                    this.setState({cells: cells});\r\n                }, travWaitTime * i);\r\n            }\r\n            setTimeout(() => {\r\n                resolve();\r\n                }, totalTime);\r\n        });\r\n\r\n    }\r\n\r\n    async animateFinalPath(path){\r\n        const totalTime = (path.length * finalWaitTime) + finalWaitTime;\r\n        //console.log(\"total fp time = \" + totalTime);\r\n        return new Promise(resolve =>{\r\n            for(let i=0; i<path.length; i++){\r\n                setTimeout(()=>{\r\n                    //add cases for cl, clw, g, a\r\n                    const cells = this.state.cells.slice();\r\n                    \r\n                    cells[path[i].position] = \"t\";\r\n\r\n                    //this.state.cells[path[i].position] = \"fp\";\r\n                    path[i].status = \"fp\";\r\n                    if(i>0){\r\n                        if(path[i-1].position === this.state.startLocation){\r\n                            cells[path[i-1].position] = \"s\";\r\n                            //this.state.cells[path[i-1].position] = \"s\";\r\n                            path[i-1].status = \"s\";\r\n                        }\r\n                        else{\r\n                            cells[path[i-1].position] = \"fp\";\r\n                            path[i-1].status = \"fp\";\r\n                        }\r\n                    }\r\n                    if(i === path.length-1){\r\n                        cells[path[i].position] = \"tg\";\r\n                        //this.state.cells[path[i].position] = \"tg\";\r\n                        path[i].status = \"tg\";\r\n                    }   \r\n                    this.setState({cells: cells});\r\n                }, finalWaitTime * i);\r\n            }\r\n            setTimeout(() => {\r\n                resolve();\r\n                }, totalTime);\r\n        });\r\n\r\n\r\n    }\r\n\r\n    updateWalls(dataCells){\r\n        const cells = this.state.cells.slice();\r\n        for(let i=0; i<mazeSize; i++){\r\n            //console.log(\"NEWEST DEBUG\");\r\n            //console.log(\"dataCells[i].status is: \" + dataCells[i].status);\r\n            if(blockedMemory[i] === true){\r\n                cells[i] = \"ws\";\r\n                dataCells[i].status = \"ws\";\r\n                //this.state.cells[i] = \"ws\";\r\n            }\r\n            else if(this.state.cells[i] === \"w\" || this.state.cells[i] === \"ws\"){\r\n                cells[i] = \"w\";\r\n                dataCells[i].status = \"w\";\r\n                //this.state.cells[i] = \"w\";\r\n            }\r\n        }\r\n        this.setState({cells: cells});\r\n    }\r\n\r\n    resetBoardStates(dataCells, clCells){\r\n        var currentCell;\r\n        const cells = this.state.cells.slice();\r\n        for(let i=0; i<clCells.length; i++){\r\n            currentCell = clCells[i];\r\n            switch(dataCells[currentCell.position].status){\r\n                case \"pp\":\r\n                    cells[currentCell.position] = \"c\";\r\n                    //this.state.cells[currentCell.position] = \"c\";\r\n                    dataCells[currentCell.position].status = \"c\";\r\n                    break;\r\n                case \"ppw\":\r\n                    cells[currentCell.position] = \"w\";\r\n                    //this.state.cells[currentCell.position] = \"w\";\r\n                    dataCells[currentCell.position].status = \"w\";\r\n                    break;\r\n                case \"cl\":\r\n                    cells[currentCell.position] = \"c\";\r\n                    //this.state.cells[currentCell.position] = \"c\";\r\n                    dataCells[currentCell.position].status = \"c\";\r\n                    break;\r\n                case \"clw\":\r\n                    cells[currentCell.position] = \"w\";\r\n                    //this.state.cells[currentCell.position] = \"w\";\r\n                    dataCells[currentCell.position].status = \"w\";\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }    \r\n        this.setState({cells: cells});\r\n    }\r\n\r\n    //run forwardAStar algorithm\r\n    //oList is the open List of cells, dataCells is the set of cells in the maze\r\n    async forwardAStar(oList, dataCells){\r\n        var counter = 0;\r\n        var finalPathTaken = [];\r\n        var finalpt = 0;\r\n\r\n        //set search value for all states to be 0 (done in initialization)\r\n\r\n        \r\n        var currentCell = oList.dequeue().element;\r\n        //var startPosition = currentCell;\r\n        //console.log(\"first currentCell: \" + currentCell.position);\r\n\r\n        //check blocked status of neighbors of starting node\r\n        this.checkNeighbors(dataCells, currentCell);\r\n\r\n\r\n        //until goal is reached\r\n        while(currentCell !== dataCells[this.state.goalLocation]){\r\n            \r\n            this.updateWalls(dataCells);\r\n            //console.log(\"infinite loop current cell is: \" + currentCell.position + \",\" + currentCell.status);\r\n            counter++;\r\n            currentCell.gVal = 0;\r\n            currentCell.searchValue = counter;\r\n            dataCells[this.state.goalLocation].gVal = Number.MAX_SAFE_INTEGER;\r\n\r\n            var newOList = new PriorityQueue();\r\n            var newCList = new PriorityQueue();\r\n            \r\n            currentCell.fVal = currentCell.gVal + currentCell.hVal;\r\n            newOList.enqueue(currentCell, currentCell.fVal);\r\n\r\n            var visitedCells = this.computePath(newOList, newCList, dataCells, counter);\r\n            //console.log(visitedCells);\r\n\r\n            //probably need to make this a function\r\n            //b************\r\n            if(newOList.isEmpty()){\r\n                alert(\"Unable to find target\");\r\n                \r\n                blockedMemory.fill(false);\r\n                this.updateWalls(dataCells);\r\n\r\n                const cells = this.state.cells.slice();\r\n                //reset \"t\" cell back to clear\r\n                if(currentCell.status !== \"s\")\r\n                    cells[currentCell.position] = \"c\";\r\n                \r\n                this.setState({cells: cells,\r\n                                inProgress: false});\r\n\r\n\r\n                return;\r\n            }\r\n\r\n            if(this.state.showExtraAnimations){\r\n                await this.animateClosedList(visitedCells);\r\n            }\r\n            \r\n            //console.log(response);\r\n            //console.log(\"smiles first >:(\");\r\n\r\n            //printprojectpath\r\n            this.debugProjectedPath(dataCells, currentCell, \"f\");\r\n            //animateprojectedpath\r\n\r\n\r\n            var pointer = dataCells[this.state.goalLocation];\r\n            var upTo = currentCell;\r\n            var path = [];\r\n            var pt = 0;\r\n            //calculate path for one iteration\r\n            //uncomment to include start position in projected path\r\n            //path[pt] = currentCell;\r\n            //pt++;\r\n            while(upTo !== dataCells[this.state.goalLocation]){\r\n                while(pointer.treePointer !== upTo){\r\n                    pointer = pointer.treePointer;\r\n                }\r\n                //also pointer status to p here\r\n                path[pt] = pointer;\r\n                pt++;\r\n\r\n                upTo = pointer;\r\n                pointer = dataCells[this.state.goalLocation];\r\n            }\r\n\r\n\r\n\r\n            if(this.state.showExtraAnimations){\r\n              await this.animateProjectedPath(path);\r\n            }\r\n            else{\r\n                this.showProjectedPath(path);\r\n            }\r\n\r\n            //console.log(\"wait success\");\r\n\r\n            //display blocked memory\r\n            /*\r\n            for(let i=0; i<mazeSize; i++){\r\n                console.log(\"blocked \" + i + \": \" + blockedMemory[i]);\r\n            }*/\r\n\r\n\r\n            path = [];\r\n            pt = 0;\r\n            pointer = dataCells[this.state.goalLocation];\r\n            //console.log(pointer.status);\r\n            //console.log(pointer.position);\r\n            //console.log(pointer.treePointer);\r\n\r\n            //add current cell position to path\r\n            path[pt] = currentCell;\r\n            pt++;\r\n    \r\n            //traverse path of tree pointers until goal or wall\r\n            while(currentCell !== dataCells[this.state.goalLocation]){\r\n                if(pointer.treePointer === currentCell){\r\n                    //check if wall hit\r\n                    if(pointer.status === \"w\" || pointer.status === \"ws\" || pointer.status === \"clw\" || pointer.status === \"ppw\"){\r\n                        break;\r\n                    }\r\n                    currentCell = pointer;\r\n                    //console.log(\"agent moved to \" + currentCell.position);\r\n    \r\n                    //keep track of total final path\r\n                    finalPathTaken[finalpt] = pointer;\r\n                    finalpt++;\r\n\r\n                    //keep track of this iteration\r\n                    path[pt] = pointer;\r\n                    pt++;\r\n    \r\n                    pointer = dataCells[this.state.goalLocation];\r\n    \r\n                    //check new neighbors for blocked status\r\n                    this.checkNeighbors(dataCells, currentCell);\r\n                }\r\n                else\r\n                    pointer = pointer.treePointer;\r\n            }\r\n        \r\n\r\n            await this.animateTraversal(path);\r\n            \r\n            this.resetBoardStates(dataCells, visitedCells);\r\n\r\n            //countExpanded(newCList);\r\n            /*for(let i=0; i<mazeSize; i++){\r\n                console.log(\"position: \" + dataCells[i].position + \" h: \" + dataCells[i].hVal + \" g: \" + dataCells[i].gVal + \" f: \" + dataCells[i].fVal);\r\n            }*/\r\n            \r\n        }\r\n\r\n\r\n\r\n        console.log(\"goal reached at \" + currentCell.position);\r\n        console.log(\"final path taken: \");\r\n        for(let i = 0; i< finalpt; i++){\r\n            console.log(\"{\" + finalPathTaken[i].status + \" \" + finalPathTaken[i].position + \"} \");\r\n        }\r\n\r\n        //animate final path, update to prepare for next maze\r\n        this.updateWalls(dataCells);\r\n        await this.animateFinalPath(finalPathTaken);\r\n        this.state.goalLocation = null;\r\n        this.setState({inProgress: false,\r\n                        updateNeeded: true});\r\n    }\r\n\r\n    handleFasClick(){\r\n        if(this.state.inProgress){\r\n            return;\r\n        }\r\n        if(this.state.startLocation === null || this.state.goalLocation === null){\r\n            alert(\"must have a start and goal\");\r\n            return;\r\n        }        \r\n        \r\n        this.setState({inProgress: true,\r\n                        previousMaze: this.state.cells,\r\n                        previousStart: this.state.startLocation,\r\n                        previousGoal: this.state.goalLocation});\r\n\r\n        var dataCells = [];\r\n        this.establishMaze(\"f\", dataCells);\r\n        var oList = new PriorityQueue();\r\n        oList.enqueue(dataCells[this.state.startLocation], dataCells[this.state.startLocation].fVal);\r\n        this.forwardAStar(oList, dataCells);\r\n    }\r\n\r\n    async handleResetClick(){\r\n        if(this.state.inProgress){\r\n            return;\r\n        }\r\n        console.log(\"in reset click\");\r\n        // for(let i=0; i<mazeSize; i++){\r\n        //     console.log(i + \": \" + this.state.previousMaze[i]);\r\n        // }\r\n        return new Promise(resolve =>{\r\n            this.setState({cells: this.state.previousMaze,\r\n                startLocation: this.state.previousStart,\r\n                goalLocation: this.state.previousGoal,\r\n                updateNeeded: false});  \r\n                resolve(); \r\n        });        \r\n\r\n    }\r\n\r\n\r\n    //renders a single cell (at index i) in the maze\r\n    renderCell(i){\r\n        return( \r\n            <Cell \r\n                value = {this.state.cells[i]}\r\n                onMouseDown = {() => this.handleMouseDown(i)}\r\n                onMouseEnter = {() => this.handleMouseEnter(i)}\r\n                onMouseUp = {() => this.handleMouseUp(i)}/>\r\n            );\r\n    }\r\n    \r\n    render() {\r\n        var maze = [];\r\n        for(let i=0; i<numRows; i++){\r\n            var row = [];\r\n            for(let j=0; j<numColumns; j++){\r\n                row.push(\r\n                    <div key={i*numColumns+j} className=\"cell\">\r\n                        {this.renderCell(i*numColumns+j)}\r\n                    </div>\r\n                );\r\n            }\r\n            maze.push(\r\n                <div key={\"row\"+i}className = \"row\">\r\n                    {row}\r\n                </div>\r\n            );\r\n        }\r\n\r\n        return (\r\n            //renders menu buttons\r\n            //renders mazeSize cells in 5 rows of 5\r\n            <div>\r\n                <div className=\"menu\">\r\n                    <button \r\n                        className=\"start-button\"\r\n                        onClick={() => this.handleButtonClick(\"s\")}\r\n                        >place start</button>\r\n                    <button \r\n                        className=\"goal-button\"\r\n                        onClick={() => this.handleButtonClick(\"g\")}\r\n                        >place goal</button>\r\n                    <button \r\n                        className=\"wall-button\"\r\n                        onClick={() => this.handleButtonClick(\"w\")}\r\n                        >place wall</button>\r\n                    <button \r\n                        className=\"clear-button\"\r\n                        onClick={() => this.handleButtonClick(\"c\")}\r\n                        >clear cell</button>\r\n                    <button\r\n                        className=\"randomize\"\r\n                        onClick={() => this.handleRandomizeClick()}\r\n                        >randomize maze</button>\r\n                    <button\r\n                        className=\"clear\"\r\n                        onClick={() => this.handleClearClick()}\r\n                        >clear maze</button>\r\n                    <button\r\n                        className=\"ToggleAnimations\"\r\n                        onClick={() => this.handleAnimationsClick()}\r\n                        >Toggle Extra Animations</button>\r\n                        \r\n                </div>\r\n                <div className = \"maze\">\r\n                    {maze}\r\n                </div>\r\n                <div className = \"debug\">\r\n                    <button \r\n                    className=\"debug\"\r\n                    onClick={() => this.handleDebugClick()}>debug</button>\r\n                </div>\r\n                <div className=\"fas\">\r\n                    <button className=\"fas\"\r\n                    onClick={() => this.handleFasClick()}>fas</button>\r\n                </div>\r\n                <div className=\"reset\">\r\n                    <button\r\n                        className=\"reset\"\r\n                        onClick={() => this.handleResetClick()}>reset</button>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n","import React, {Component} from 'react';\r\n//import Cell from './Cell/Cell';\r\nimport Maze from './Maze/Maze';\r\nimport './MazeSolver.css';\r\n//import PriorityQueue from './PriorityQueue';\r\n\r\nexport default class MazeSolver extends Component{\r\n    \r\n    constructor(props){\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            \r\n            <div>\r\n                \r\n                <div className=\"maze\">\r\n                    <Maze />\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}","import React from 'react';\nimport './App.css';\nimport MazeSolver from './MazeSolver/MazeSolver';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <MazeSolver></MazeSolver>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}