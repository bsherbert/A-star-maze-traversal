{"version":3,"sources":["MazeSolver/Cell/Cell.jsx","MazeSolver/PriorityQueue.jsx","MazeSolver/DataCell.jsx","MazeSolver/Maze/Maze.jsx","MazeSolver/MazeSolver.jsx","App.js","serviceWorker.js","index.js"],"names":["Cell","this","props","value","className","onMouseDown","onMouseEnter","onMouseUp","Component","QElement","element","priority","PriorityQueue","items","qElement","contain","i","length","gVal","splice","push","isEmpty","shift","console","log","position","DataCell","status","fVal","hVal","treePointer","searchValue","blockedMemory","Array","numRows","fill","previousMaze","previousStart","previousGoal","Maze","state","cells","action","mouseIsDown","startLocation","goalLocation","inProgress","showExtraAnimations","setState","slice","handleMouseDown","buttonClicked","s","Math","floor","random","r","q","dataCells","currentCell","alg","pointer","upTo","path","pt","Number","MAX_SAFE_INTEGER","abs","below","right","above","left","oList","cList","counter","visitedCells","dequeue","enqueue","contains","front","undefined","totalTime","Promise","resolve","setTimeout","clCells","finalPathTaken","finalpt","checkNeighbors","updateWalls","newOList","newCList","computePath","alert","animateClosedList","debugProjectedPath","animateProjectedPath","showProjectedPath","animateTraversal","resetBoardStates","animateFinalPath","establishMaze","forwardAStar","handleMouseEnter","handleMouseUp","maze","row","j","key","renderCell","onClick","handleButtonClick","handleRandomizeClick","handleClearClick","handleAnimationsClick","handleDebugClick","handleFasClick","handleResetClick","MazeSolver","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"2VAGqBA,G,mLACR,IAAD,OACJ,OAAOC,KAAKC,MAAMC,OACd,IAAK,IACD,OACI,4BACIC,UAAU,iBACVC,YAAc,kBAAM,EAAKH,MAAMG,eAC/BC,aAAe,kBAAM,EAAKJ,MAAMI,gBAChCC,UAAY,kBAAM,EAAKL,MAAMK,eAKzC,IAAK,IACD,OACI,4BACIH,UAAU,iBACVC,YAAc,kBAAM,EAAKH,MAAMG,eAC/BC,aAAe,kBAAM,EAAKJ,MAAMI,gBAChCC,UAAY,kBAAM,EAAKL,MAAMK,eAIzC,IAAK,KACD,OACI,4BACIH,UAAU,sBACVC,YAAc,kBAAM,EAAKH,MAAMG,eAC/BC,aAAe,kBAAM,EAAKJ,MAAMI,gBAChCC,UAAY,kBAAM,EAAKL,MAAMK,eAIzC,IAAK,IACD,OACI,4BACIH,UAAU,kBACVC,YAAc,kBAAM,EAAKH,MAAMG,eAC/BC,aAAe,kBAAM,EAAKJ,MAAMI,gBAChCC,UAAY,kBAAM,EAAKL,MAAMK,eAKzC,IAAK,IACD,OACI,4BACIH,UAAU,iBACVC,YAAc,kBAAM,EAAKH,MAAMG,eAC/BC,aAAe,kBAAM,EAAKJ,MAAMI,gBAChCC,UAAY,kBAAM,EAAKL,MAAMK,eAMzC,IAAK,KACD,OACI,4BACIH,UAAU,kBACVC,YAAc,kBAAM,EAAKH,MAAMG,eAC/BC,aAAe,kBAAM,EAAKJ,MAAMI,gBAChCC,UAAY,kBAAM,EAAKL,MAAMK,eAKzC,IAAK,MACD,OACI,4BACIH,UAAU,oBACVC,YAAc,kBAAM,EAAKH,MAAMG,eAC/BC,aAAe,kBAAM,EAAKJ,MAAMI,gBAChCC,UAAY,kBAAM,EAAKL,MAAMK,eAKzC,IAAK,KACD,OACI,4BACIH,UAAU,2BACVC,YAAc,kBAAM,EAAKH,MAAMG,eAC/BC,aAAe,kBAAM,EAAKJ,MAAMI,gBAChCC,UAAY,kBAAM,EAAKL,MAAMK,eAKzC,IAAK,MACD,OACI,4BACIH,UAAU,6BACVC,YAAc,kBAAM,EAAKH,MAAMG,eAC/BC,aAAe,kBAAM,EAAKJ,MAAMI,gBAChCC,UAAY,kBAAM,EAAKL,MAAMK,eAKzC,IAAK,IACD,OACI,4BACIH,UAAU,sBACVC,YAAc,kBAAM,EAAKH,MAAMG,eAC/BC,aAAe,kBAAM,EAAKJ,MAAMI,gBAChCC,UAAY,kBAAM,EAAKL,MAAMK,cAE5B,KAGb,IAAK,KACD,OAEI,4BACIH,UAAU,2BACVC,YAAc,kBAAM,EAAKH,MAAMG,eAC/BC,aAAe,kBAAM,EAAKJ,MAAMI,gBAChCC,UAAY,kBAAM,EAAKL,MAAMK,cAE5B,KAGb,IAAK,KACD,OAEI,4BACIH,UAAU,uBACVC,YAAc,kBAAM,EAAKH,MAAMG,eAC/BC,aAAe,kBAAM,EAAKJ,MAAMI,gBAChCC,UAAY,kBAAM,EAAKL,MAAMK,cAE9B,yBAAKH,UAAU,aAG1B,QACI,OACI,4BACIA,UAAU,iBACVC,YAAc,kBAAM,EAAKH,MAAMG,eAC/BC,aAAe,kBAAM,EAAKJ,MAAMI,gBAChCC,UAAY,kBAAM,EAAKL,MAAMK,oB,GA9InBC,cCCrBC,EACT,WAAYC,EAASC,GACpB,oBACGV,KAAKS,QAAUA,EACfT,KAAKU,SAAWA,GAKHC,E,WAGjB,aACC,oBACGX,KAAKY,MAAQ,G,oDAKTH,EAASC,GASb,IANA,IAAIG,EAAW,IAAIL,EAASC,EAASC,GACjCI,GAAU,EAKLC,EAAI,EAAGA,EAAIf,KAAKY,MAAMI,OAAQD,IAAK,CACxC,GAAGf,KAAKY,MAAMG,GAAGL,WAAaG,EAASH,SAAS,CAC5C,GAAGV,KAAKY,MAAMG,GAAGN,QAAQQ,KAAOJ,EAASJ,QAAQQ,KAC7C,SAEC,GAAGjB,KAAKY,MAAMG,GAAGN,QAAQQ,OAASJ,EAASJ,QAAQQ,KAAK,CACzDjB,KAAKY,MAAMM,OAAOH,EAAE,EAAE,EAAEF,GACxBC,GAAU,EACV,MAGAd,KAAKY,MAAMM,OAAOH,EAAE,EAAEF,GACtBC,GAAU,EACV,MAGH,GAAId,KAAKY,MAAMG,GAAGL,SAAWG,EAASH,SAAU,CAGjDV,KAAKY,MAAMM,OAAOH,EAAG,EAAGF,GACxBC,GAAU,EACV,OAMHA,GACDd,KAAKY,MAAMO,KAAKN,K,gCAYpB,OAAIb,KAAKoB,UACE,YACJpB,KAAKY,MAAMS,U,8BAQlB,OAAIrB,KAAKoB,UACE,uBACJpB,KAAKY,MAAM,K,6BAQlB,OAAIZ,KAAKoB,UACE,uBACJpB,KAAKY,MAAMZ,KAAKY,MAAMI,OAAS,K,gCAOtC,OAA6B,IAAtBhB,KAAKY,MAAMI,S,+BAIbP,GACL,IAAK,IAAIM,EAAI,EAAGA,EAAIf,KAAKY,MAAMI,OAAQD,IACnC,GAAGf,KAAKY,MAAMG,GAAGN,UAAYA,EACzB,OAAO,EAEf,OAAO,I,kCAIP,IAAI,IAAIM,EAAE,EAAGA,EAAEf,KAAKY,MAAMI,OAAQD,IAC9BO,QAAQC,IAAI,SAAWR,EAAI,aAAef,KAAKY,MAAMG,GAAGN,QAAQe,c,KCnHvDC,EAEjB,WAAYC,GAAQ,oBAChB1B,KAAK0B,OAASA,EACd1B,KAAKiB,KAAO,KACZjB,KAAK2B,KAAO,KACZ3B,KAAK4B,KAAO,KACZ5B,KAAKwB,SAAW,KAChBxB,KAAK6B,YAAc,KACnB7B,KAAK8B,YAAc,GCKvBC,EAAgBC,MALHC,MAKmBC,MAAK,GACrCC,EAAe,GACfC,EAAgB,KAChBC,EAAe,KAEEC,E,kDACjB,WAAYrC,GAAQ,IAAD,8BACf,cAAMA,IACDsC,MAAQ,CAETC,MAAOR,MAfFC,MAekBC,KAAK,KAE5BO,OAAQ,IAERC,aAAa,EACbC,cAAe,KACfC,aAAc,KACdC,YAAY,EACZC,qBAAqB,GAZV,E,4DAkBH/B,GACZ,IAAGf,KAAKuC,MAAMM,WAAd,CAEA7C,KAAK+C,SAAS,CAACL,aAAa,IAC5B,IAAMF,EAAQxC,KAAKuC,MAAMC,MAAMQ,QAIJ,MAAxBhD,KAAKuC,MAAMC,MAAMzB,GAChBf,KAAK+C,SAAS,CAACJ,cAAe,OAEF,MAAxB3C,KAAKuC,MAAMC,MAAMzB,IACrBf,KAAK+C,SAAS,CAACH,aAAc,OAIR,MAAtB5C,KAAKuC,MAAME,QACsB,OAA7BzC,KAAKuC,MAAMI,gBACVH,EAAMxC,KAAKuC,MAAMI,eAAiB,KAEtC3C,KAAK+C,SAAS,CAACJ,cAAe5B,IAC9ByB,EAAMzB,GAAK,KAEe,MAAtBf,KAAKuC,MAAME,SACgB,OAA5BzC,KAAKuC,MAAMK,eACVJ,EAAMxC,KAAKuC,MAAMK,cAAgB,KAErC5C,KAAK+C,SAAS,CAACH,aAAc7B,IAC7ByB,EAAMzB,GAAK,KAKfyB,EAAMzB,GAAKf,KAAKuC,MAAME,OAEtBzC,KAAK+C,SAAS,CAACP,MAAOA,O,uCAKTzB,GACVf,KAAKuC,MAAMG,aACV1C,KAAKiD,gBAAgBlC,K,oCAKfA,GACVf,KAAK+C,SAAS,CAACL,aAAa,M,wCAIdQ,GACdlD,KAAK+C,SAAS,CACVN,OAAQS,M,6CAMZ,IAAGlD,KAAKuC,MAAMM,WAAd,CASA,IAPA,IAAML,EAAQxC,KAAKuC,MAAMC,MAAMQ,QAE3BG,EAAIC,KAAKC,MA7FJpB,KA6FUmB,KAAKE,UAIpBC,EAAIJ,EACFI,IAAMJ,GACRI,EAAIH,KAAKC,MAnGJpB,KAmGUmB,KAAKE,UAIxB,IAAI,IAAIvC,EAAE,EAAGA,EAvGJkB,KAuGgBlB,IAAI,CACzB,IAAIyC,EAAIJ,KAAKC,MAAsB,IAAhBD,KAAKE,UAEpBd,EAAMzB,GADPyC,GAAK,GACO,IAGA,IAGnBhB,EAAMW,GAAK,IACXX,EAAMe,GAAK,IACXvD,KAAK+C,SAAS,CAACP,MAAOA,EACNG,cAAeQ,EACfP,aAAcW,O,yCAM3BvD,KAAKuC,MAAMM,YAGd7C,KAAK+C,SAAS,CAACP,MAAOR,MA7HbC,MA6H6BC,KAAK,KAC3BS,cAAe,KACfC,aAAc,S,8CAI3B5C,KAAKuC,MAAMM,YAGd7C,KAAK+C,SAAS,CAACD,qBAAsB9C,KAAKuC,MAAMO,wB,yCAKhDxB,QAAQC,IAAI,iBACZD,QAAQC,IAAI,qBAAuBvB,KAAKuC,MAAME,QAC9CnB,QAAQC,IAAI,oBAAsBvB,KAAKuC,MAAMC,OAC7ClB,QAAQC,IAAI,qBAAuBvB,KAAKuC,MAAMI,eAC9CrB,QAAQC,IAAI,oBAAsBvB,KAAKuC,MAAMK,cAC7CtB,QAAQC,IAAI,oBAAsBvB,KAAKuC,MAAMG,e,gCAWvCe,GACN,IAAI,IAAI1C,EAAE,EAAGA,EA5JJkB,KA4JgBlB,IACrBO,QAAQC,IAAI,UAAYR,GACxBO,QAAQC,IAAI,aAAekC,EAAU1C,GAAGS,UACxCF,QAAQC,IAAI,WAAakC,EAAU1C,GAAGW,QACtCJ,QAAQC,IAAI,SAAWkC,EAAU1C,GAAGE,MACpCK,QAAQC,IAAI,SAAWkC,EAAU1C,GAAGY,MACpCL,QAAQC,IAAI,SAAWkC,EAAU1C,GAAGa,MACpCN,QAAQC,IAAI,cAAgBkC,EAAU1C,GAAGe,aACzCR,QAAQC,IAAI,gBAAkBkC,EAAU1C,GAAGc,e,yCAIhC4B,EAAWC,EAAaC,GACvC,IAAIC,EAAUH,EAAUzD,KAAKuC,MAAMK,cAC/BiB,EAAOH,EACPI,EAAO,GACPC,EAAK,EAET,GAAW,MAARJ,EAMC,IALArC,QAAQC,IAAI,oBACZD,QAAQC,IAAI,IAAMmC,EAAYhC,OAAS,IAAMgC,EAAYlC,SAAW,MACpEsC,EAAKC,GAAML,EACXK,IAEMF,IAASJ,EAAUzD,KAAKuC,MAAMK,eAAc,CAC9C,KAAMgB,EAAQ/B,cAAgBgC,GAC1BD,EAAUA,EAAQ/B,YAEtBP,QAAQC,IAAI,IAAMqC,EAAQlC,OAAS,IAAMkC,EAAQpC,SAAW,MAC5DsC,EAAKC,GAAMH,EACXG,IAEAF,EAAOD,EACPA,EAAUH,EAAUzD,KAAKuC,MAAMK,iB,oCAQ7Be,EAAKF,GAEf1B,EAAcG,MAAK,GAGnB,IAAI,IAAInB,EAAE,EAAGA,EA1MJkB,KA0MgBlB,IACrB0C,EAAU1C,GAAK,IAAIU,EAASzB,KAAKuC,MAAMC,MAAMzB,IAC7C0C,EAAU1C,GAAGS,SAAWT,EAI5B,IAAI,IAAIA,EAAE,EAAGA,EAhNJkB,KAgNgBlB,IACrB0C,EAAU1C,GAAGE,KAAO+C,OAAOC,iBAC3BR,EAAU1C,GAAGY,KAAOqC,OAAOC,iBAChB,MAARN,IACCF,EAAU1C,GAAGa,KAAOwB,KAAKc,IAAInD,EAtN1B,GAsNyCf,KAAKuC,MAAMK,aAtNpD,IAsN+EQ,KAAKc,IAAId,KAAKC,MAAMtC,EAtNnG,IAsNmHqC,KAAKC,MAAMrD,KAAKuC,MAAMK,aAtNzI,Q,qCA6NAa,EAAWC,GAEtB,IAAIS,EAAQT,EAAYlC,SA/Nb,GAgOP4C,EAAQV,EAAYlC,SAAW,EAC/B6C,EAAQX,EAAYlC,SAjOb,GAkOP8C,EAAOZ,EAAYlC,SAAW,EAS/B2C,EAzOMlC,OA2O0B,MAA5BwB,EAAUU,GAAOzC,QAA8C,QAA5B+B,EAAUU,GAAOzC,QAAgD,QAA5B+B,EAAUU,GAAOzC,QAAgD,OAA5B+B,EAAUU,GAAOzC,SAG7HK,EAAcoC,IAAS,IAI5Bf,KAAKC,MAAMK,EAAYlC,SApPf,MAoPwC4B,KAAKC,MAAMe,EApPnD,MAsPwB,MAA5BX,EAAUW,GAAO1C,QAA8C,QAA5B+B,EAAUW,GAAO1C,QAAgD,QAA5B+B,EAAUW,GAAO1C,QAAgD,OAA5B+B,EAAUW,GAAO1C,SAE7HK,EAAcqC,IAAS,IAI5BC,GAAS,IAEuB,MAA5BZ,EAAUY,GAAO3C,QAA8C,QAA5B+B,EAAUY,GAAO3C,QAAgD,QAA5B+B,EAAUY,GAAO3C,QAAgD,OAA5B+B,EAAUY,GAAO3C,SAE7HK,EAAcsC,IAAS,IAI5BjB,KAAKC,MAAMK,EAAYlC,SApQf,MAoQwC4B,KAAKC,MAAMiB,EApQnD,MAsQuB,MAA3Bb,EAAUa,GAAM5C,QAA6C,QAA3B+B,EAAUa,GAAM5C,QAA+C,QAA3B+B,EAAUa,GAAM5C,QAA+C,OAA3B+B,EAAUa,GAAM5C,SAEzHK,EAAcuC,IAAQ,M,kCAMtBC,EAAOC,EAAOf,EAAWgB,GAUjC,IARA,IAAIC,EAAe,GAIfhB,EAAca,EAAMI,UAAUlE,QAI5BgD,EAAUzD,KAAKuC,MAAMK,cAAc3B,KAAOyC,EAAYzC,MAAK,CAE7DuD,EAAMI,QAAQlB,EAAaA,EAAY/B,MAKvC+C,EAAavD,KAAKuC,GAOlB,IAAIS,EAAQT,EAAYlC,SAtSjB,GAuSH4C,EAAQV,EAAYlC,SAAW,EAC/B6C,EAAQX,EAAYlC,SAxSjB,GAySH8C,EAAOZ,EAAYlC,SAAW,EA6GlC,GA1GG2C,EA1SElC,OA4SGF,EAAcoC,IAAWK,EAAMK,SAASpB,EAAUU,KAAYI,EAAMM,SAASpB,EAAUU,MACpFV,EAAUU,GAAOrC,YAAc2C,IAE9BhB,EAAUU,GAAOlD,KAAO+C,OAAOC,iBAC/BR,EAAUU,GAAOrC,YAAc2C,GAEhChB,EAAUU,GAAOlD,KAAOyC,EAAYzC,KAAO,IAC1CwC,EAAUU,GAAOlD,KAAOyC,EAAYzC,KAAO,GAE/CwC,EAAUU,GAAOtC,YAAc6B,EAE5Ba,EAAMO,QAAQrE,UAAYgD,EAAUU,IACnCI,EAAMI,UAGVlB,EAAUU,GAAOxC,KAAO8B,EAAUU,GAAOlD,KAAOwC,EAAUU,GAAOvC,KACjE2C,EAAMK,QAAQnB,EAAUU,GAAQV,EAAUU,GAAOxC,QAOtDyB,KAAKC,MAAMK,EAAYlC,SArUnB,MAqU4C4B,KAAKC,MAAMe,EArUvD,MAuUCrC,EAAcqC,IAAWI,EAAMK,SAASpB,EAAUW,KAAYG,EAAMM,SAASpB,EAAUW,MACpFX,EAAUW,GAAOtC,YAAc2C,IAE9BhB,EAAUW,GAAOnD,KAAO+C,OAAOC,iBAC/BR,EAAUW,GAAOtC,YAAc2C,GAEhChB,EAAUW,GAAOnD,KAAOyC,EAAYzC,KAAO,IAC1CwC,EAAUW,GAAOnD,KAAOyC,EAAYzC,KAAO,GAE/CwC,EAAUW,GAAOvC,YAAc6B,EAE5Ba,EAAMO,QAAQrE,UAAYgD,EAAUW,IACnCG,EAAMI,UAEVlB,EAAUW,GAAOzC,KAAO8B,EAAUW,GAAOnD,KAAOwC,EAAUW,GAAOxC,KAEjE2C,EAAMK,QAAQnB,EAAUW,GAAQX,EAAUW,GAAOzC,QAOtD0C,GAAS,IAEJtC,EAAcsC,IAAWG,EAAMK,SAASpB,EAAUY,KAAYE,EAAMM,SAASpB,EAAUY,MACpFZ,EAAUY,GAAOvC,YAAc2C,IAE9BhB,EAAUY,GAAOpD,KAAO+C,OAAOC,iBAC/BR,EAAUY,GAAOvC,YAAc2C,GAEhChB,EAAUY,GAAOpD,KAAOyC,EAAYzC,KAAO,IAC1CwC,EAAUY,GAAOpD,KAAOyC,EAAYzC,KAAO,GAE/CwC,EAAUY,GAAOxC,YAAc6B,EAE5Ba,EAAMO,QAAQrE,UAAYgD,EAAUY,IACnCE,EAAMI,UAEVlB,EAAUY,GAAO1C,KAAO8B,EAAUY,GAAOpD,KAAOwC,EAAUY,GAAOzC,KAEjE2C,EAAMK,QAAQnB,EAAUY,GAAQZ,EAAUY,GAAO1C,QAOtDyB,KAAKC,MAAMK,EAAYlC,SAvXnB,MAuX4C4B,KAAKC,MAAMiB,EAvXvD,MAyXCvC,EAAcuC,IAAUE,EAAMK,SAASpB,EAAUa,KAAWC,EAAMM,SAASpB,EAAUa,MAClFb,EAAUa,GAAMxC,YAAc2C,IAE7BhB,EAAUa,GAAMrD,KAAO+C,OAAOC,iBAC9BR,EAAUa,GAAMxC,YAAc2C,GAE/BhB,EAAUa,GAAMrD,KAAOyC,EAAYzC,KAAO,IACzCwC,EAAUa,GAAMrD,KAAOyC,EAAYzC,KAAO,GAE9CwC,EAAUa,GAAMzC,YAAc6B,EAE3Ba,EAAMO,QAAQrE,UAAYgD,EAAUa,IACnCC,EAAMI,UAEVlB,EAAUa,GAAM3C,KAAO8B,EAAUa,GAAMrD,KAAOwC,EAAUa,GAAM1C,KAE9D2C,EAAMK,QAAQnB,EAAUa,GAAOb,EAAUa,GAAM3C,aAapCoD,KAJnBrB,EAAca,EAAMI,UAAUlE,SAK1B,OAAOiE,EAgBf,OAVAH,EAAMK,QAAQlB,EAAaA,EAAY/B,MAUhC+C,I,iFAIaA,G,qFACdM,EAzaK,GAyaQN,EAAa1D,OAzarB,G,kBA0aJ,IAAIiE,SAAQ,SAAAC,GACf,IAD0B,IAAD,WACjBnE,GACJoE,YAAW,WACP,IAAMzB,EAAcgB,EAAa3D,GAE3ByB,EAAQ,EAAKD,MAAMC,MAAMQ,QAEL,MAAvBU,EAAYhC,QACXc,EAAMkB,EAAYlC,UAAY,KAE9BkC,EAAYhC,OAAS,MAEK,MAAtBgC,EAAYhC,QAAwC,OAAvBgC,EAAYhC,SAC7Cc,EAAMkB,EAAYlC,UAAY,MAE9BkC,EAAYhC,OAAS,OAEzB,EAAKqB,SAAS,CAACP,MAAOA,MA3bvB,GA8bazB,IAnBZA,EAAE,EAAGA,EAAE2D,EAAa1D,OAAQD,IAAK,EAAjCA,GAqBRoE,YAAW,WACPD,MACGF,O,sLAIYlB,G,qFACbkB,EAtcC,GAscYlB,EAAK9C,OAtcjB,G,kBAwcA,IAAIiE,SAAQ,SAAAC,GACf,IAD0B,IAAD,WACjBnE,GACJoE,YAAW,WAEP,IAAM3C,EAAQ,EAAKD,MAAMC,MAAMQ,QACT,MAAnBc,EAAK/C,GAAGW,QAAqC,OAAnBoC,EAAK/C,GAAGW,QACjCc,EAAMsB,EAAK/C,GAAGS,UAAY,KAE1BsC,EAAK/C,GAAGW,OAAS,MAEM,MAAnBoC,EAAK/C,GAAGW,QAAqC,OAAnBoC,EAAK/C,GAAGW,QAAsC,QAAnBoC,EAAK/C,GAAGW,SACjEc,EAAMsB,EAAK/C,GAAGS,UAAY,MAE1BsC,EAAK/C,GAAGW,OAAS,OAErB,EAAKqB,SAAS,CAACP,MAAOA,MAvd3B,GAwdiBzB,IAfZA,EAAE,EAAGA,EAAE+C,EAAK9C,OAAQD,IAAK,EAAzBA,GAiBRoE,YAAW,WACPD,MACGF,O,0IAIDlB,GAEd,IADA,IAAMtB,EAAQxC,KAAKuC,MAAMC,MAAMQ,QACvBjC,EAAE,EAAGA,EAAE+C,EAAK9C,OAAQD,IACF,MAAnB+C,EAAK/C,GAAGW,QAAqC,OAAnBoC,EAAK/C,GAAGW,QACjCc,EAAMsB,EAAK/C,GAAGS,UAAY,KAE1BsC,EAAK/C,GAAGW,OAAS,MAEM,MAAnBoC,EAAK/C,GAAGW,QAAqC,OAAnBoC,EAAK/C,GAAGW,QAAsC,QAAnBoC,EAAK/C,GAAGW,SACjEc,EAAMsB,EAAK/C,GAAGS,UAAY,MAE1BsC,EAAK/C,GAAGW,OAAS,OAGzB1B,KAAK+C,SAAS,CAACP,MAAOA,M,gFAGHsB,G,qFACbkB,EAjfO,IAifMlB,EAAK9C,OAjfX,I,kBAmfN,IAAIiE,SAAQ,SAAAC,GACf,IAD0B,IAAD,WACjBnE,GACJoE,YAAW,WACP,IAAM3C,EAAQ,EAAKD,MAAMC,MAAMQ,QACT,MAAnBc,EAAK/C,GAAGW,SACPc,EAAMsB,EAAK/C,GAAGS,UAAY,IAE1BsC,EAAK/C,GAAGW,OAAS,KAElBX,EAAE,IACE+C,EAAK/C,EAAE,GAAGS,WAAa,EAAKe,MAAMI,eACjCH,EAAMsB,EAAK/C,EAAE,GAAGS,UAAY,IAE5BsC,EAAK/C,EAAE,GAAGW,OAAS,MAGnBc,EAAMsB,EAAK/C,EAAE,GAAGS,UAAY,KAE5BsC,EAAK/C,EAAE,GAAGW,OAAS,OAK3B,EAAKqB,SAAS,CAACP,MAAOA,MA1gBrB,IA2gBazB,IAvBdA,EAAE,EAAGA,EAAE+C,EAAK9C,OAAQD,IAAK,EAAzBA,GAyBRoE,YAAW,WACPD,MACGF,O,kLAKQlB,G,qFACbkB,EAphBQ,GAohBKlB,EAAK9C,OAphBV,G,kBAshBP,IAAIiE,SAAQ,SAAAC,GACf,IAD0B,IAAD,WACjBnE,GACJoE,YAAW,WAEP,IAAM3C,EAAQ,EAAKD,MAAMC,MAAMQ,QAE/BR,EAAMsB,EAAK/C,GAAGS,UAAY,IAG1BsC,EAAK/C,GAAGW,OAAS,KACdX,EAAE,IACE+C,EAAK/C,EAAE,GAAGS,WAAa,EAAKe,MAAMI,eACjCH,EAAMsB,EAAK/C,EAAE,GAAGS,UAAY,IAE5BsC,EAAK/C,EAAE,GAAGW,OAAS,MAGnBc,EAAMsB,EAAK/C,EAAE,GAAGS,UAAY,KAC5BsC,EAAK/C,EAAE,GAAGW,OAAS,OAGxBX,IAAM+C,EAAK9C,OAAO,IACjBwB,EAAMsB,EAAK/C,GAAGS,UAAY,KAE1BsC,EAAK/C,GAAGW,OAAS,MAErB,EAAKqB,SAAS,CAACP,MAAOA,MAhjBpB,GAijBazB,IA1BfA,EAAE,EAAGA,EAAE+C,EAAK9C,OAAQD,IAAK,EAAzBA,GA4BRoE,YAAW,WACPD,MACGF,O,oIAMHvB,GAER,IADA,IAAMjB,EAAQxC,KAAKuC,MAAMC,MAAMQ,QACvBjC,EAAE,EAAGA,EAjkBJkB,KAikBgBlB,KAGG,IAArBgB,EAAchB,IACbyB,EAAMzB,GAAK,KACX0C,EAAU1C,GAAGW,OAAS,MAGM,MAAxB1B,KAAKuC,MAAMC,MAAMzB,IAAsC,OAAxBf,KAAKuC,MAAMC,MAAMzB,KACpDyB,EAAMzB,GAAK,IACX0C,EAAU1C,GAAGW,OAAS,KAI9B1B,KAAK+C,SAAS,CAACP,MAAOA,M,uCAGTiB,EAAW2B,GAGxB,IAFA,IAAI1B,EACElB,EAAQxC,KAAKuC,MAAMC,MAAMQ,QACvBjC,EAAE,EAAGA,EAAEqE,EAAQpE,OAAQD,IAE3B,OAAO0C,GADPC,EAAc0B,EAAQrE,IACOS,UAAUE,QACnC,IAAK,KACDc,EAAMkB,EAAYlC,UAAY,IAE9BiC,EAAUC,EAAYlC,UAAUE,OAAS,IACzC,MACJ,IAAK,MACDc,EAAMkB,EAAYlC,UAAY,IAE9BiC,EAAUC,EAAYlC,UAAUE,OAAS,IACzC,MACJ,IAAK,KACDc,EAAMkB,EAAYlC,UAAY,IAE9BiC,EAAUC,EAAYlC,UAAUE,OAAS,IACzC,MACJ,IAAK,MACDc,EAAMkB,EAAYlC,UAAY,IAE9BiC,EAAUC,EAAYlC,UAAUE,OAAS,IAMrD1B,KAAK+C,SAAS,CAACP,MAAOA,M,4EAKP+B,EAAOd,G,+FAClBgB,EAAU,EACVY,EAAiB,GACjBC,EAAU,EAKV5B,EAAca,EAAMI,UAAUlE,QAKlCT,KAAKuF,eAAe9B,EAAWC,G,UAIzBA,IAAgBD,EAAUzD,KAAKuC,MAAMK,c,oBAEvC5C,KAAKwF,YAAY/B,GAEjBgB,IACAf,EAAYzC,KAAO,EACnByC,EAAY5B,YAAc2C,EAC1BhB,EAAUzD,KAAKuC,MAAMK,cAAc3B,KAAO+C,OAAOC,iBAE7CwB,EAAW,IAAI9E,EACf+E,EAAW,IAAI/E,EAEnB+C,EAAY/B,KAAO+B,EAAYzC,KAAOyC,EAAY9B,KAClD6D,EAASb,QAAQlB,EAAaA,EAAY/B,MAEtC+C,EAAe1E,KAAK2F,YAAYF,EAAUC,EAAUjC,EAAWgB,IAKhEgB,EAASrE,U,wBACRwE,MAAM,yBAEN7D,EAAcG,MAAK,GACnBlC,KAAKwF,YAAY/B,GAEXjB,EAAQxC,KAAKuC,MAAMC,MAAMQ,QAEL,MAAvBU,EAAYhC,SACXc,EAAMkB,EAAYlC,UAAY,KAElCxB,KAAK+C,SAAS,CAACP,MAAOA,EACNK,YAAY,I,+BAM7B7C,KAAKuC,MAAMO,oB,kCACJ9C,KAAK6F,kBAAkBnB,G,QAmBjC,IAZA1E,KAAK8F,mBAAmBrC,EAAWC,EAAa,KAI5CE,EAAUH,EAAUzD,KAAKuC,MAAMK,cAC/BiB,EAAOH,EACPI,EAAO,GACPC,EAAK,EAKHF,IAASJ,EAAUzD,KAAKuC,MAAMK,eAAc,CAC9C,KAAMgB,EAAQ/B,cAAgBgC,GAC1BD,EAAUA,EAAQ/B,YAGtBiC,EAAKC,GAAMH,EACXG,IAEAF,EAAOD,EACPA,EAAUH,EAAUzD,KAAKuC,MAAMK,c,IAKhC5C,KAAKuC,MAAMO,oB,kCACN9C,KAAK+F,qBAAqBjC,G,gCAG9B9D,KAAKgG,kBAAkBlC,G,QAY3BA,EAAO,GACPC,EAAK,EACLH,EAAUH,EAAUzD,KAAKuC,MAAMK,cAM/BkB,EAAKC,GAAML,EACXK,I,WAGML,IAAgBD,EAAUzD,KAAKuC,MAAMK,c,oBACpCgB,EAAQ/B,cAAgB6B,E,oBAED,MAAnBE,EAAQlC,QAAqC,OAAnBkC,EAAQlC,QAAsC,QAAnBkC,EAAQlC,QAAuC,QAAnBkC,EAAQlC,O,qDAG5FgC,EAAcE,EAIdyB,EAAeC,GAAW1B,EAC1B0B,IAGAxB,EAAKC,GAAMH,EACXG,IAEAH,EAAUH,EAAUzD,KAAKuC,MAAMK,cAG/B5C,KAAKuF,eAAe9B,EAAWC,G,wBAG/BE,EAAUA,EAAQ/B,Y,iDAIpB7B,KAAKiG,iBAAiBnC,G,QAE5B9D,KAAKkG,iBAAiBzC,EAAWiB,G,uBAarC,IAFApD,QAAQC,IAAI,mBAAqBmC,EAAYlC,UAC7CF,QAAQC,IAAI,sBACJR,EAAI,EAAGA,EAAGuE,EAASvE,IACvBO,QAAQC,IAAI,IAAM8D,EAAetE,GAAGW,OAAS,IAAM2D,EAAetE,GAAGS,SAAW,M,OAIpFxB,KAAKwF,YAAY/B,G,UACXzD,KAAKmG,iBAAiBd,G,QAC5BrF,KAAKuC,MAAMK,aAAe,KAC1B5C,KAAK+C,SAAS,CAACF,YAAY,I,iJAI3B,IAAG7C,KAAKuC,MAAMM,WAGd,GAAgC,OAA7B7C,KAAKuC,MAAMI,eAAsD,OAA5B3C,KAAKuC,MAAMK,aAAnD,CAIA5C,KAAK+C,SAAS,CAACF,YAAY,IAC3BV,EAAenC,KAAKuC,MAAMC,MAC1BJ,EAAgBpC,KAAKuC,MAAMI,cAC3BN,EAAerC,KAAKuC,MAAMK,aAC1B,IAAIa,EAAY,GAChBzD,KAAKoG,cAAc,IAAK3C,GACxB,IAAIc,EAAQ,IAAI5D,EAChB4D,EAAMK,QAAQnB,EAAUzD,KAAKuC,MAAMI,eAAgBc,EAAUzD,KAAKuC,MAAMI,eAAehB,MACvF3B,KAAKqG,aAAa9B,EAAOd,QAXrBmC,MAAM,gC,yCAeP5F,KAAKuC,MAAMM,YAGd7C,KAAK+C,SAAS,CAACP,MAAOL,EACNQ,cAAeP,EACfQ,aAAcP,M,iCAKvBtB,GAAG,IAAD,OACT,OACI,kBAAC,EAAD,CACIb,MAASF,KAAKuC,MAAMC,MAAMzB,GAC1BX,YAAe,kBAAM,EAAK6C,gBAAgBlC,IAC1CV,aAAgB,kBAAM,EAAKiG,iBAAiBvF,IAC5CT,UAAa,kBAAM,EAAKiG,cAAcxF,Q,+BAM9C,IAFM,IAAD,OACDyF,EAAO,GACHzF,EAAE,EAAGA,EA10BL,GA00BgBA,IAAI,CAExB,IADA,IAAI0F,EAAM,GACFC,EAAE,EAAGA,EA70BN,GA60BoBA,IACvBD,EAAItF,KACA,yBAAKwF,IA/0BN,GA+0BW5F,EAAa2F,EAAGvG,UAAU,QAC/BH,KAAK4G,WAh1BX,GAg1BsB7F,EAAa2F,KAI1CF,EAAKrF,KACD,yBAAKwF,IAAK,MAAM5F,EAAEZ,UAAY,OACzBsG,IAKb,OAGI,6BACI,yBAAKtG,UAAU,QACX,4BACIA,UAAU,eACV0G,QAAS,kBAAM,EAAKC,kBAAkB,OAF1C,eAIA,4BACI3G,UAAU,cACV0G,QAAS,kBAAM,EAAKC,kBAAkB,OAF1C,cAIA,4BACI3G,UAAU,cACV0G,QAAS,kBAAM,EAAKC,kBAAkB,OAF1C,cAIA,4BACI3G,UAAU,eACV0G,QAAS,kBAAM,EAAKC,kBAAkB,OAF1C,cAIA,4BACI3G,UAAU,YACV0G,QAAS,kBAAM,EAAKE,yBAFxB,kBAIA,4BACI5G,UAAU,QACV0G,QAAS,kBAAM,EAAKG,qBAFxB,cAIA,4BACI7G,UAAU,mBACV0G,QAAS,kBAAM,EAAKI,0BAFxB,4BAMJ,yBAAK9G,UAAY,QACZqG,GAEL,yBAAKrG,UAAY,SACb,4BACAA,UAAU,QACV0G,QAAS,kBAAM,EAAKK,qBAFpB,UAIJ,yBAAK/G,UAAU,OACX,4BAAQA,UAAU,MAClB0G,QAAS,kBAAM,EAAKM,mBADpB,QAGJ,yBAAKhH,UAAU,SACX,4BACIA,UAAU,QACV0G,QAAS,kBAAM,EAAKO,qBAFxB,e,GA/3Bc7G,aCbb8G,G,wDAEjB,WAAYpH,GAAO,IAAD,8BACd,cAAMA,IACDsC,MAAQ,GAFC,E,qDAMd,OAEI,6BAEI,yBAAKpC,UAAU,QACX,kBAAC,EAAD,Y,GAboBI,cCMzB+G,MARf,WACE,OACE,yBAAKnH,UAAU,OACb,kBAAC,EAAD,QCKcoH,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,SDyHpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLlH,QAAQkH,MAAMA,EAAMC,c","file":"static/js/main.64764a28.chunk.js","sourcesContent":["import React, {Component} from 'react';\r\nimport './Cell.css';\r\n\r\nexport default class Cell extends Component{\r\n    render(){\r\n        switch(this.props.value){\r\n            case \"c\":\r\n                return( \r\n                    <button \r\n                        className=\"cell open-cell\"\r\n                        onMouseDown= {() => this.props.onMouseDown()}\r\n                        onMouseEnter= {() => this.props.onMouseEnter()}\r\n                        onMouseUp= {() => this.props.onMouseUp()}\r\n                    >\r\n                        \r\n                    </button>\r\n                );\r\n            case \"w\":\r\n                return( \r\n                    <button \r\n                        className=\"cell wall-cell\"\r\n                        onMouseDown= {() => this.props.onMouseDown()}\r\n                        onMouseEnter= {() => this.props.onMouseEnter()}\r\n                        onMouseUp= {() => this.props.onMouseUp()}\r\n                    >\r\n                    </button>\r\n                );\r\n            case \"ws\":\r\n                return( \r\n                    <button \r\n                        className=\"cell wall-cell-seen\"\r\n                        onMouseDown= {() => this.props.onMouseDown()}\r\n                        onMouseEnter= {() => this.props.onMouseEnter()}\r\n                        onMouseUp= {() => this.props.onMouseUp()}\r\n                    >\r\n                    </button>\r\n                );\r\n            case \"s\":\r\n                return( \r\n                    <button \r\n                        className=\"cell start-cell\"\r\n                        onMouseDown= {() => this.props.onMouseDown()}\r\n                        onMouseEnter= {() => this.props.onMouseEnter()}\r\n                        onMouseUp= {() => this.props.onMouseUp()}\r\n                    >\r\n\r\n                    </button>\r\n                );\r\n            case \"g\":\r\n                return( \r\n                    <button \r\n                        className=\"cell goal-cell\"\r\n                        onMouseDown= {() => this.props.onMouseDown()}\r\n                        onMouseEnter= {() => this.props.onMouseEnter()}\r\n                        onMouseUp= {() => this.props.onMouseUp()}\r\n                    >\r\n\r\n                    </button>\r\n                );\r\n        \r\n            case \"cl\":\r\n                return( \r\n                    <button \r\n                        className=\"cell cList-cell\"\r\n                        onMouseDown= {() => this.props.onMouseDown()}\r\n                        onMouseEnter= {() => this.props.onMouseEnter()}\r\n                        onMouseUp= {() => this.props.onMouseUp()}\r\n                    >\r\n\r\n                    </button>\r\n                );    \r\n            case \"clw\":\r\n                return( \r\n                    <button \r\n                        className=\"cell cList-cell-w\"\r\n                        onMouseDown= {() => this.props.onMouseDown()}\r\n                        onMouseEnter= {() => this.props.onMouseEnter()}\r\n                        onMouseUp= {() => this.props.onMouseUp()}\r\n                    >\r\n\r\n                    </button>\r\n                );\r\n            case \"pp\":\r\n                return( \r\n                    <button \r\n                        className=\"cell projected-path-cell\"\r\n                        onMouseDown= {() => this.props.onMouseDown()}\r\n                        onMouseEnter= {() => this.props.onMouseEnter()}\r\n                        onMouseUp= {() => this.props.onMouseUp()}\r\n                    >\r\n\r\n                    </button>\r\n                ); \r\n            case \"ppw\":\r\n                return(\r\n                    <button \r\n                        className=\"cell projected-path-cell-w\"\r\n                        onMouseDown= {() => this.props.onMouseDown()}\r\n                        onMouseEnter= {() => this.props.onMouseEnter()}\r\n                        onMouseUp= {() => this.props.onMouseUp()}\r\n                    >\r\n\r\n                    </button>\r\n                );\r\n            case \"t\":\r\n                return( \r\n                    <button \r\n                        className=\"cell traversed-cell\"\r\n                        onMouseDown= {() => this.props.onMouseDown()}\r\n                        onMouseEnter= {() => this.props.onMouseEnter()}\r\n                        onMouseUp= {() => this.props.onMouseUp()}\r\n                    >\r\n                        {\"J\"}\r\n                    </button>\r\n                );\r\n            case \"tg\":\r\n                return( \r\n                    \r\n                    <button \r\n                        className=\"cell traversed-cell-goal\"\r\n                        onMouseDown= {() => this.props.onMouseDown()}\r\n                        onMouseEnter= {() => this.props.onMouseEnter()}\r\n                        onMouseUp= {() => this.props.onMouseUp()}\r\n                    >\r\n                        {\"J\"}\r\n                    </button>\r\n                );\r\n            case \"fp\":\r\n                return(\r\n                    \r\n                    <button \r\n                        className=\"cell final-path-cell\"\r\n                        onMouseDown= {() => this.props.onMouseDown()}\r\n                        onMouseEnter= {() => this.props.onMouseEnter()}\r\n                        onMouseUp= {() => this.props.onMouseUp()}\r\n                    >\r\n                       <div className=\"texture\"></div>\r\n                    </button>\r\n                ); \r\n            default:\r\n                return( \r\n                    <button \r\n                        className=\"cell open-cell\"\r\n                        onMouseDown= {() => this.props.onMouseDown()}\r\n                        onMouseEnter= {() => this.props.onMouseEnter()}\r\n                        onMouseUp= {() => this.props.onMouseUp()}\r\n                    >\r\n\r\n                    </button>\r\n                );\r\n        }\r\n    }\r\n}","//code for priority queue from geeksforgeeks.org/implementation-priority-queue-javascript/\r\n\r\n// User defined class \r\n// to store element and its priority \r\nexport class QElement { \r\n    constructor(element, priority) \r\n    { \r\n        this.element = element; \r\n        this.priority = priority; \r\n    } \r\n} \r\n  \r\n// PriorityQueue class \r\nexport default class PriorityQueue { \r\n  \r\n    // An array is used to implement priority \r\n    constructor()  \r\n    { \r\n        this.items = []; \r\n    } \r\n\r\n    // enqueue function to add element \r\n    // to the queue as per priority \r\n    enqueue(element, priority) \r\n    { \r\n        // creating object from queue element \r\n        var qElement = new QElement(element, priority); \r\n        var contain = false; \r\n    \r\n        // iterating through the entire \r\n        // item array to add element at the \r\n        // correct location of the Queue \r\n        for (var i = 0; i < this.items.length; i++) { \r\n            if(this.items[i].priority === qElement.priority){\r\n                if(this.items[i].element.gVal > qElement.element.gVal){\r\n                    continue;\r\n                }\r\n                else if(this.items[i].element.gVal === qElement.element.gVal){\r\n                    this.items.splice(i+1,0,qElement);\r\n                    contain = true;\r\n                    break;\r\n                }\r\n                else{\r\n                    this.items.splice(i,0,qElement);\r\n                    contain = true;\r\n                    break;\r\n                }\r\n            }\r\n            else if (this.items[i].priority > qElement.priority) { \r\n                // Once the correct location is found it is \r\n                // enqueued \r\n                this.items.splice(i, 0, qElement); \r\n                contain = true; \r\n                break; \r\n            } \r\n        } \r\n    \r\n        // if the element have the highest priority \r\n        // it is added at the end of the queue \r\n        if (!contain) { \r\n            this.items.push(qElement); \r\n        } \r\n    } \r\n\r\n    // dequeue method to remove \r\n    // element from the queue \r\n    dequeue() \r\n    { \r\n        // return the dequeued element \r\n        // and remove it. \r\n        // if the queue is empty \r\n        // returns Underflow \r\n        if (this.isEmpty()) \r\n            return \"Underflow\"; \r\n        return this.items.shift(); \r\n    } \r\n\r\n    // front function \r\n    front() \r\n    { \r\n        // returns the highest priority element \r\n        // in the Priority queue without removing it. \r\n        if (this.isEmpty()) \r\n            return \"No elements in Queue\"; \r\n        return this.items[0]; \r\n    } \r\n\r\n    // rear function \r\n    rear() \r\n    { \r\n        // returns the lowest priorty \r\n        // element of the queue \r\n        if (this.isEmpty()) \r\n            return \"No elements in Queue\"; \r\n        return this.items[this.items.length - 1]; \r\n    } \r\n\r\n    // isEmpty function \r\n    isEmpty() \r\n    { \r\n        // return true if the queue is empty. \r\n        return this.items.length === 0; \r\n    } \r\n\r\n    //check if provided object is present in queue\r\n    contains(element){\r\n        for (var i = 0; i < this.items.length; i++){\r\n            if(this.items[i].element === element)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    printList(){\r\n        for(let i=0; i<this.items.length; i++){\r\n            console.log(\"index \" + i + \" position \" + this.items[i].element.position);\r\n        }\r\n    }\r\n} \r\n\r\n","export default class DataCell{\r\n\r\n    constructor(status){\r\n        this.status = status;\r\n        this.gVal = null;\r\n        this.fVal = null;\r\n        this.hVal = null;\r\n        this.position = null;\r\n        this.treePointer = null;\r\n        this.searchValue = 0;\r\n    }\r\n\r\n}","import React, {Component} from 'react';\r\nimport './Maze.css';\r\nimport Cell from '../Cell/Cell'\r\nimport PriorityQueue from '../PriorityQueue';\r\nimport DataCell from '../DataCell';\r\n\r\n//global variables\r\nconst numColumns = 50;\r\nconst numRows = 30;\r\nconst mazeSize = numRows*numColumns;\r\nconst clWaitTime = 25;\r\nconst ppWaitTime = 50;\r\nconst travWaitTime = 100;\r\nconst finalWaitTime = 75;\r\nvar blockedMemory = Array(mazeSize).fill(false);\r\nvar previousMaze = [];\r\nvar previousStart = null;\r\nvar previousGoal = null;\r\n\r\nexport default class Maze extends Component{ \r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            //initial layout of cells in maze\r\n            cells: Array(mazeSize).fill(\"c\"),\r\n            //track buttons for placing maze items\r\n            action: \"c\",\r\n            //tracks if mouse is down for smoother UX\r\n            mouseIsDown: false,\r\n            startLocation: null,\r\n            goalLocation: null,\r\n            inProgress: false,\r\n            showExtraAnimations: false,\r\n        };\r\n    }\r\n\r\n    \r\n    //adjusts selected cell based on last button pressed\r\n    handleMouseDown(i){\r\n        if(this.state.inProgress)\r\n            return;\r\n        this.setState({mouseIsDown: true});\r\n        const cells = this.state.cells.slice();\r\n\r\n        //reset start/goal location if overwritten\r\n\r\n        if(this.state.cells[i] === \"s\"){\r\n            this.setState({startLocation: null});\r\n        }\r\n        else if(this.state.cells[i] === \"g\"){\r\n            this.setState({goalLocation: null});\r\n        }\r\n         \r\n        //allow only one start/goal\r\n        if(this.state.action === \"s\"){\r\n            if(this.state.startLocation !== null){\r\n                cells[this.state.startLocation] = \"c\";\r\n            }\r\n            this.setState({startLocation: i});\r\n            cells[i] = \"s\";           \r\n        }\r\n        else if(this.state.action === \"g\"){\r\n            if(this.state.goalLocation !== null){\r\n                cells[this.state.goalLocation] = \"c\";\r\n            }\r\n            this.setState({goalLocation: i});\r\n            cells[i] = \"g\";\r\n        }\r\n        \r\n\r\n        //create duplicate maze to maintain immutability\r\n        cells[i] = this.state.action;\r\n        \r\n        this.setState({cells: cells});\r\n\r\n    }\r\n\r\n    //adjusts selected cell based on last button pressed\r\n    handleMouseEnter(i){\r\n        if(this.state.mouseIsDown){\r\n            this.handleMouseDown(i);\r\n        }\r\n    }\r\n\r\n    //adjusts selected cell based on last button pressed\r\n    handleMouseUp(i){\r\n        this.setState({mouseIsDown: false});\r\n    }\r\n\r\n    //adjusts the action variable based on the last button pressed\r\n    handleButtonClick(buttonClicked){\r\n        this.setState({\r\n            action: buttonClicked,\r\n        });\r\n    }\r\n\r\n    //create a random maze layout\r\n    handleRandomizeClick(){  \r\n        if(this.state.inProgress)\r\n            return;\r\n        const cells = this.state.cells.slice();\r\n        //pick a random starting point\r\n        let s = Math.floor(Math.random() * mazeSize);\r\n        //console.log(s);\r\n\r\n        //pick a random goal that is not the same as the start point\r\n        let r = s;\r\n        while(r === s){\r\n            r = Math.floor(Math.random() * mazeSize)\r\n        }\r\n\r\n        //give every non start/goal cell a 30% chance to be marked as a wall\r\n        for(let i=0; i<mazeSize; i++){\r\n            let q = Math.floor(Math.random() * 101);\r\n            if(q <= 30){\r\n                cells[i] = \"w\";\r\n            }\r\n            else{\r\n                cells[i] = \"c\";\r\n            }    \r\n        }\r\n        cells[s] = \"s\";\r\n        cells[r] = \"g\"; \r\n        this.setState({cells: cells,\r\n                        startLocation: s,\r\n                        goalLocation: r});\r\n\r\n    }\r\n\r\n    //clear the maze to be all empty cells\r\n    handleClearClick(){\r\n        if(this.state.inProgress){\r\n            return;\r\n        }\r\n        this.setState({cells: Array(mazeSize).fill(\"c\"),\r\n                        startLocation: null,\r\n                        goalLocation: null,});\r\n    }\r\n\r\n    handleAnimationsClick(){\r\n        if(this.state.inProgress){\r\n            return;\r\n        }\r\n        this.setState({showExtraAnimations: !this.state.showExtraAnimations});\r\n    }\r\n\r\n    //shows logs for debugging\r\n    handleDebugClick(){\r\n        console.log(\"debug pressed\");\r\n        console.log(\"current action is \" + this.state.action);\r\n        console.log(\"current state is \" + this.state.cells);\r\n        console.log(\"start location is \" + this.state.startLocation);\r\n        console.log(\"goal location is \" + this.state.goalLocation);\r\n        console.log(\"mouse pressed is \" + this.state.mouseIsDown);\r\n        \r\n\r\n        //display blocked memory\r\n        /*\r\n        for(let i=0; i<mazeSize; i++){\r\n            console.log(\"blocked \" + i + \": \" + blockedMemory[i]);\r\n        }\r\n*/\r\n    }\r\n\r\n    debugMaze(dataCells){\r\n        for(let i=0; i<mazeSize; i++){\r\n            console.log(\"index: \" + i);\r\n            console.log(\"position: \" + dataCells[i].position);\r\n            console.log(\"status: \" + dataCells[i].status);\r\n            console.log(\"gVal: \" + dataCells[i].gVal);\r\n            console.log(\"fVal: \" + dataCells[i].fVal);\r\n            console.log(\"hVal: \" + dataCells[i].hVal);\r\n            console.log(\"searchVal: \" + dataCells[i].searchValue);\r\n            console.log(\"treePointer: \" + dataCells[i].treePointer);\r\n        }\r\n    }\r\n\r\n    debugProjectedPath(dataCells, currentCell, alg){\r\n        var pointer = dataCells[this.state.goalLocation];\r\n        var upTo = currentCell;\r\n        var path = [];\r\n        var pt = 0;\r\n\r\n        if(alg === \"f\"){\r\n            console.log(\"Projected Path: \");\r\n            console.log(\"{\" + currentCell.status + \",\" + currentCell.position + \"} \");\r\n            path[pt] = currentCell;\r\n            pt++;\r\n\r\n            while(upTo !== dataCells[this.state.goalLocation]){\r\n                while(pointer.treePointer !== upTo){\r\n                    pointer = pointer.treePointer;\r\n                }\r\n                console.log(\"{\" + pointer.status + \",\" + pointer.position + \"} \");\r\n                path[pt] = pointer;\r\n                pt++;\r\n\r\n                upTo = pointer;\r\n                pointer = dataCells[this.state.goalLocation];\r\n            }\r\n        }\r\n\r\n    }\r\n    \r\n    //alg parameter adjusts setup based on \"f\", \"b\", or \"a\" for forward, backward, and adaptive a*, respectively\r\n    //a cells (x,y) location in maze based on id is (id%numColumns, id/numColumns)\r\n    establishMaze(alg, dataCells){\r\n        //reset the agent's memory of the maze before re-running the algorithm  \r\n        blockedMemory.fill(false);\r\n        \r\n        //fill array of dataCells based on Cell status\r\n        for(let i=0; i<mazeSize; i++){\r\n            dataCells[i] = new DataCell(this.state.cells[i]);\r\n            dataCells[i].position = i;\r\n        }\r\n        \r\n        //fill dataCells with f,g,h,search values\r\n        for(let i=0; i<mazeSize; i++){\r\n            dataCells[i].gVal = Number.MAX_SAFE_INTEGER;\r\n            dataCells[i].fVal = Number.MAX_SAFE_INTEGER;\r\n            if(alg === \"f\"){\r\n                dataCells[i].hVal = Math.abs(i%numColumns - this.state.goalLocation%numColumns) + Math.abs(Math.floor(i/numColumns) - Math.floor(this.state.goalLocation/numColumns));\r\n            }\r\n            //this.debugMaze(dataCells);\r\n        }\r\n    }\r\n\r\n    //looks at cells adjacent to the current cell, sets any that are walls to true in blockedMemory \r\n    checkNeighbors(dataCells, currentCell){\r\n\r\n        var below = currentCell.position + numColumns;\r\n        var right = currentCell.position + 1;\r\n        var above = currentCell.position - numColumns;\r\n        var left = currentCell.position - 1;\r\n        //check below\r\n        //console.log(\"current position: \" + currentCell.position);\r\n        //console.log(\"below: \" + below);\r\n        //console.log(\"right: \" + right);\r\n        //console.log(\"above: \" + above);\r\n        //console.log(\"left: \" + left);\r\n        \r\n        //console.log(\"in check neighbors\");\r\n        if(below < mazeSize){\r\n            //console.log(\"1\");\r\n            if(dataCells[below].status === \"w\" || dataCells[below].status === \"clw\" || dataCells[below].status === \"ppw\" || dataCells[below].status === \"ws\"){\r\n                //console.log(\"2\");\r\n\r\n                blockedMemory[below] = true;\r\n            }\r\n        }\r\n        //check right\r\n        if(Math.floor(currentCell.position/numColumns) === Math.floor(right/numColumns)){\r\n            //console.log(\"3\");\r\n            if(dataCells[right].status === \"w\" || dataCells[right].status === \"clw\" || dataCells[right].status === \"ppw\" || dataCells[right].status === \"ws\"){\r\n                //console.log(\"4\");\r\n                blockedMemory[right] = true;\r\n            }\r\n        }\r\n        //check above\r\n        if(above >= 0){\r\n            //console.log(\"5\");\r\n            if(dataCells[above].status === \"w\" || dataCells[above].status === \"clw\" || dataCells[above].status === \"ppw\" || dataCells[above].status === \"ws\"){\r\n                //console.log(\"6\");\r\n                blockedMemory[above] = true;\r\n            }\r\n        }\r\n        //check left\r\n        if(Math.floor(currentCell.position/numColumns) === Math.floor(left/numColumns)){\r\n            //console.log(\"7\");\r\n            if(dataCells[left].status === \"w\" || dataCells[left].status === \"clw\" || dataCells[left].status === \"ppw\" || dataCells[left].status === \"ws\"){\r\n                //console.log(\"8\");\r\n                blockedMemory[left] = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    //computes the projected path of a single iteration of any A* algorithm\r\n    computePath(oList, cList, dataCells, counter){\r\n        //track visited cells in order (for animation)\r\n        var visitedCells = [];\r\n        //var counter = 0;\r\n\r\n        //determine starting position\r\n        var currentCell = oList.dequeue().element;\r\n\r\n        //console.log(\"starting compute path on \" + currentCell.position);\r\n        //while g value of goal is greater than g value of current cell\r\n        while(dataCells[this.state.goalLocation].gVal > currentCell.gVal){\r\n            //add current position to closed list\r\n            cList.enqueue(currentCell, currentCell.fVal);\r\n            //console.log(currentCell.position + \" added to closed list\");\r\n            //cList.printList();\r\n            \r\n            //track visited cells\r\n            visitedCells.push(currentCell);\r\n            //counter++;\r\n            //console.log(currentCell.position + \" set to cl\");\r\n            //this.handleDebugClick();\r\n\r\n\r\n            //for every non wall neighbor of currentCell\r\n            var below = currentCell.position + numColumns;\r\n            var right = currentCell.position + 1;\r\n            var above = currentCell.position - numColumns;\r\n            var left = currentCell.position - 1;\r\n\r\n            //if bottom neighbor is inbounds\r\n            if(below < mazeSize){\r\n                //if neighbor is not blocked, not start, and has a search value less than counter\r\n                if(!blockedMemory[below] && !cList.contains(dataCells[below]) && !oList.contains(dataCells[below])){\r\n                    if(dataCells[below].searchValue < counter){\r\n                        //set g and search value\r\n                        dataCells[below].gVal = Number.MAX_SAFE_INTEGER;\r\n                        dataCells[below].searchValue = counter;\r\n                    }\r\n                    if(dataCells[below].gVal > currentCell.gVal + 1){\r\n                        dataCells[below].gVal = currentCell.gVal + 1;\r\n                    }\r\n                    dataCells[below].treePointer = currentCell;\r\n                    //if cell below is in oList, remove\r\n                    if(oList.front().element === dataCells[below]){\r\n                        oList.dequeue();\r\n                    }\r\n                    //update f value, add below cell to open list\r\n                    dataCells[below].fVal = dataCells[below].gVal + dataCells[below].hVal;\r\n                    oList.enqueue(dataCells[below], dataCells[below].fVal);\r\n\r\n                    //look at this line in eclipse project if issues, not using a temp Cell to do things\r\n                    //console.log(\"(below) {\" + dataCells[below].position + \"} added to olist\");\r\n                }\r\n            }\r\n            //if right neighbor is inbounds\r\n            if(Math.floor(currentCell.position/numColumns) === Math.floor(right/numColumns)){\r\n                //if neighbor is not blocked, not start, and has a search value less than counter\r\n                if(!blockedMemory[right] && !cList.contains(dataCells[right]) && !oList.contains(dataCells[right])){\r\n                    if(dataCells[right].searchValue < counter){\r\n                        //set g and search value\r\n                        dataCells[right].gVal = Number.MAX_SAFE_INTEGER;\r\n                        dataCells[right].searchValue = counter;\r\n                    }\r\n                    if(dataCells[right].gVal > currentCell.gVal + 1){\r\n                        dataCells[right].gVal = currentCell.gVal + 1;\r\n                    }\r\n                    dataCells[right].treePointer = currentCell;\r\n                    //if cell right is in oList, remove\r\n                    if(oList.front().element === dataCells[right]){\r\n                        oList.dequeue();\r\n                    }\r\n                    dataCells[right].fVal = dataCells[right].gVal + dataCells[right].hVal;\r\n                    //update f value, add right cell to open list\r\n                    oList.enqueue(dataCells[right], dataCells[right].fVal);\r\n\r\n                    //look at this line in eclipse project if issues, not using a temp Cell to do things\r\n                    //console.log(\"(right) {\" + dataCells[right].position + \"} added to olist\");\r\n                }\r\n            }\r\n            //if above neighbor is inbounds\r\n            if(above >= 0){\r\n                //if neighbor is not blocked, not start, and has a search value less than counter\r\n                if(!blockedMemory[above] && !cList.contains(dataCells[above]) && !oList.contains(dataCells[above])){\r\n                    if(dataCells[above].searchValue < counter){\r\n                        //set g and search value\r\n                        dataCells[above].gVal = Number.MAX_SAFE_INTEGER;\r\n                        dataCells[above].searchValue = counter;\r\n                    }\r\n                    if(dataCells[above].gVal > currentCell.gVal + 1){\r\n                        dataCells[above].gVal = currentCell.gVal + 1;\r\n                    }\r\n                    dataCells[above].treePointer = currentCell;\r\n                    //if cell above is in oList, remove\r\n                    if(oList.front().element === dataCells[above]){\r\n                        oList.dequeue();\r\n                    }\r\n                    dataCells[above].fVal = dataCells[above].gVal + dataCells[above].hVal;\r\n                    //update f value, add above cell to open list\r\n                    oList.enqueue(dataCells[above], dataCells[above].fVal);\r\n\r\n                    //look at this line in eclipse project if issues, not using a temp Cell to do things\r\n                    //console.log(\"(above) {\" + dataCells[above].position + \"} added to olist\");\r\n                }\r\n            }\r\n            //if left neighbor is inbounds\r\n            if(Math.floor(currentCell.position/numColumns) === Math.floor(left/numColumns)){\r\n                //if neighbor is not blocked, not start, and has a search value less than counter\r\n                if(!blockedMemory[left] && !cList.contains(dataCells[left]) && !oList.contains(dataCells[left])){\r\n                    if(dataCells[left].searchValue < counter){\r\n                        //set g and search value\r\n                        dataCells[left].gVal = Number.MAX_SAFE_INTEGER;\r\n                        dataCells[left].searchValue = counter;\r\n                    }\r\n                    if(dataCells[left].gVal > currentCell.gVal + 1){\r\n                        dataCells[left].gVal = currentCell.gVal + 1;\r\n                    }\r\n                    dataCells[left].treePointer = currentCell;\r\n                    //if cell left is in oList, remove\r\n                    if(oList.front().element === dataCells[left]){\r\n                        oList.dequeue();\r\n                    }\r\n                    dataCells[left].fVal = dataCells[left].gVal + dataCells[left].hVal;\r\n                    //update f value, add left cell to open list\r\n                    oList.enqueue(dataCells[left], dataCells[left].fVal);\r\n\r\n                    //look at this line in eclipse project if issues, not using a temp Cell to do things\r\n                    //console.log(\"(left) {\" + dataCells[left].position + \"} added to olist\");\r\n                }\r\n            }\r\n\r\n            //move on to next cell in queue\r\n            //oList.printList();\r\n            currentCell = oList.dequeue().element;\r\n            //console.log(\"last dequeue'd element: \" + currentCell.position);\r\n            //console.log(\"goal at end: \" + dataCells[this.state.goalLocation].position);\r\n            //when out of cells, return\r\n            if(currentCell === undefined){\r\n                return visitedCells;\r\n            }\r\n\r\n        }\r\n        //console.log(\"shoulde probably be returning closed list here too\");\r\n        //might not do anything...\r\n        oList.enqueue(currentCell, currentCell.fVal);\r\n\r\n        //makes the goal in the open list\r\n        /*\r\n        //a***************************************\r\n        cells = this.state.cells.slice();\r\n        cells[currentCell.position] = \"ol\";\r\n        this.setState({cells: cells});\r\n        //a***************************************\r\n        */\r\n        return visitedCells;\r\n\r\n    }\r\n\r\n    async animateClosedList(visitedCells){\r\n        const totalTime = (visitedCells.length * clWaitTime) + clWaitTime\r\n        return new Promise(resolve =>{\r\n            for(let i=0; i<visitedCells.length; i++){\r\n                setTimeout(()=> {\r\n                    const currentCell = visitedCells[i];\r\n                    //a***************************************\r\n                    const cells = this.state.cells.slice();\r\n                    //console.log(\"STATUS IS \" + currentCell.status);\r\n                    if(currentCell.status === \"c\"){\r\n                        cells[currentCell.position] = \"cl\";\r\n                        //this.state.cells[currentCell.position] = \"cl\";\r\n                        currentCell.status = \"cl\"\r\n                    }\r\n                    else if(currentCell.status ===\"w\" || currentCell.status === \"ws\"){\r\n                        cells[currentCell.position] = \"clw\"\r\n                        //this.state.cells[currentCell.position] = \"clw\";\r\n                        currentCell.status = \"clw\";\r\n                    }\r\n                    this.setState({cells: cells});\r\n                    //a***************************************\r\n                    //console.log(\"hi :)\");\r\n                }, clWaitTime * i);\r\n            }\r\n            setTimeout(()=>{\r\n                resolve();\r\n                }, totalTime);\r\n        });\r\n    }\r\n\r\n    async animateProjectedPath(path){\r\n            const totalTime = (path.length * ppWaitTime) + ppWaitTime;\r\n            //console.log(\"total pp time = \" + totalTime);\r\n            return new Promise(resolve =>{\r\n                for(let i=0; i<path.length; i++){\r\n                    setTimeout(()=>{\r\n                        //add cases for cl, clw, g, a\r\n                        const cells = this.state.cells.slice();\r\n                        if(path[i].status === \"c\" || path[i].status === \"cl\"){\r\n                            cells[path[i].position] = \"pp\";\r\n                            //this.state.cells[path[i].position] = \"pp\";\r\n                            path[i].status = \"pp\";\r\n                        }\r\n                        else if(path[i].status === \"w\" || path[i].status === \"ws\" || path[i].status === \"clw\"){\r\n                            cells[path[i].position] = \"ppw\";\r\n                            //this.state.cells[path[i].position] = \"ppw\";\r\n                            path[i].status = \"ppw\";\r\n                        }\r\n                        this.setState({cells: cells});\r\n                    }, ppWaitTime * i);\r\n                }\r\n                setTimeout(() => {\r\n                    resolve();\r\n                    }, totalTime);\r\n            });        \r\n    }\r\n\r\n    showProjectedPath(path){\r\n        const cells = this.state.cells.slice();\r\n        for(let i=0; i<path.length; i++){\r\n            if(path[i].status === \"c\" || path[i].status === \"cl\"){\r\n                cells[path[i].position] = \"pp\";\r\n                //this.state.cells[path[i].position] = \"pp\";\r\n                path[i].status = \"pp\";\r\n            }\r\n            else if(path[i].status === \"w\" || path[i].status === \"ws\" || path[i].status === \"clw\"){\r\n                cells[path[i].position] = \"ppw\";\r\n                //this.state.cells[path[i].position] = \"ppw\";\r\n                path[i].status = \"ppw\";\r\n            }\r\n        }\r\n        this.setState({cells: cells});\r\n    }\r\n\r\n    async animateTraversal(path){\r\n        const totalTime = (path.length * travWaitTime) + travWaitTime;\r\n        //console.log(\"total t time = \" + totalTime);\r\n        return new Promise(resolve =>{\r\n            for(let i=0; i<path.length; i++){\r\n                setTimeout(()=>{\r\n                    const cells = this.state.cells.slice();\r\n                    if(path[i].status !== \"g\"){\r\n                        cells[path[i].position] = \"t\";\r\n                        //this.state.cells[path[i].position] = \"t\";\r\n                        path[i].status = \"t\";\r\n                    }\r\n                    if(i>0){\r\n                        if(path[i-1].position === this.state.startLocation){\r\n                            cells[path[i-1].position] = \"s\";\r\n                            //this.state.cells[path[i-1].position] = \"s\";\r\n                            path[i-1].status = \"s\";\r\n                        }\r\n                        else{\r\n                            cells[path[i-1].position] = \"pp\";\r\n                            //this.state.cells[path[i-1].position] = \"pp\";\r\n                            path[i-1].status = \"pp\";\r\n                        }\r\n                    } \r\n                    //console.log(\"status is: \" + path[i].status)\r\n\r\n                    this.setState({cells: cells});\r\n                }, travWaitTime * i);\r\n            }\r\n            setTimeout(() => {\r\n                resolve();\r\n                }, totalTime);\r\n        });\r\n\r\n    }\r\n\r\n    async animateFinalPath(path){\r\n        const totalTime = (path.length * finalWaitTime) + finalWaitTime;\r\n        //console.log(\"total fp time = \" + totalTime);\r\n        return new Promise(resolve =>{\r\n            for(let i=0; i<path.length; i++){\r\n                setTimeout(()=>{\r\n                    //add cases for cl, clw, g, a\r\n                    const cells = this.state.cells.slice();\r\n                    \r\n                    cells[path[i].position] = \"t\";\r\n\r\n                    //this.state.cells[path[i].position] = \"fp\";\r\n                    path[i].status = \"fp\";\r\n                    if(i>0){\r\n                        if(path[i-1].position === this.state.startLocation){\r\n                            cells[path[i-1].position] = \"s\";\r\n                            //this.state.cells[path[i-1].position] = \"s\";\r\n                            path[i-1].status = \"s\";\r\n                        }\r\n                        else{\r\n                            cells[path[i-1].position] = \"fp\";\r\n                            path[i-1].status = \"fp\";\r\n                        }\r\n                    }\r\n                    if(i === path.length-1){\r\n                        cells[path[i].position] = \"tg\";\r\n                        //this.state.cells[path[i].position] = \"tg\";\r\n                        path[i].status = \"tg\";\r\n                    }   \r\n                    this.setState({cells: cells});\r\n                }, finalWaitTime * i);\r\n            }\r\n            setTimeout(() => {\r\n                resolve();\r\n                }, totalTime);\r\n        });\r\n\r\n\r\n    }\r\n\r\n    updateWalls(dataCells){\r\n        const cells = this.state.cells.slice();\r\n        for(let i=0; i<mazeSize; i++){\r\n            //console.log(\"NEWEST DEBUG\");\r\n            //console.log(\"dataCells[i].status is: \" + dataCells[i].status);\r\n            if(blockedMemory[i] === true){\r\n                cells[i] = \"ws\";\r\n                dataCells[i].status = \"ws\";\r\n                //this.state.cells[i] = \"ws\";\r\n            }\r\n            else if(this.state.cells[i] === \"w\" || this.state.cells[i] === \"ws\"){\r\n                cells[i] = \"w\";\r\n                dataCells[i].status = \"w\";\r\n                //this.state.cells[i] = \"w\";\r\n            }\r\n        }\r\n        this.setState({cells: cells});\r\n    }\r\n\r\n    resetBoardStates(dataCells, clCells){\r\n        var currentCell;\r\n        const cells = this.state.cells.slice();\r\n        for(let i=0; i<clCells.length; i++){\r\n            currentCell = clCells[i];\r\n            switch(dataCells[currentCell.position].status){\r\n                case \"pp\":\r\n                    cells[currentCell.position] = \"c\";\r\n                    //this.state.cells[currentCell.position] = \"c\";\r\n                    dataCells[currentCell.position].status = \"c\";\r\n                    break;\r\n                case \"ppw\":\r\n                    cells[currentCell.position] = \"w\";\r\n                    //this.state.cells[currentCell.position] = \"w\";\r\n                    dataCells[currentCell.position].status = \"w\";\r\n                    break;\r\n                case \"cl\":\r\n                    cells[currentCell.position] = \"c\";\r\n                    //this.state.cells[currentCell.position] = \"c\";\r\n                    dataCells[currentCell.position].status = \"c\";\r\n                    break;\r\n                case \"clw\":\r\n                    cells[currentCell.position] = \"w\";\r\n                    //this.state.cells[currentCell.position] = \"w\";\r\n                    dataCells[currentCell.position].status = \"w\";\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }    \r\n        this.setState({cells: cells});\r\n    }\r\n\r\n    //run forwardAStar algorithm\r\n    //oList is the open List of cells, dataCells is the set of cells in the maze\r\n    async forwardAStar(oList, dataCells){\r\n        var counter = 0;\r\n        var finalPathTaken = [];\r\n        var finalpt = 0;\r\n\r\n        //set search value for all states to be 0 (done in initialization)\r\n\r\n        \r\n        var currentCell = oList.dequeue().element;\r\n        //var startPosition = currentCell;\r\n        //console.log(\"first currentCell: \" + currentCell.position);\r\n\r\n        //check blocked status of neighbors of starting node\r\n        this.checkNeighbors(dataCells, currentCell);\r\n\r\n\r\n        //until goal is reached\r\n        while(currentCell !== dataCells[this.state.goalLocation]){\r\n            \r\n            this.updateWalls(dataCells);\r\n            //console.log(\"infinite loop current cell is: \" + currentCell.position + \",\" + currentCell.status);\r\n            counter++;\r\n            currentCell.gVal = 0;\r\n            currentCell.searchValue = counter;\r\n            dataCells[this.state.goalLocation].gVal = Number.MAX_SAFE_INTEGER;\r\n\r\n            var newOList = new PriorityQueue();\r\n            var newCList = new PriorityQueue();\r\n            \r\n            currentCell.fVal = currentCell.gVal + currentCell.hVal;\r\n            newOList.enqueue(currentCell, currentCell.fVal);\r\n\r\n            var visitedCells = this.computePath(newOList, newCList, dataCells, counter);\r\n            //console.log(visitedCells);\r\n\r\n            //probably need to make this a function\r\n            //b************\r\n            if(newOList.isEmpty()){\r\n                alert(\"Unable to find target\");\r\n                \r\n                blockedMemory.fill(false);\r\n                this.updateWalls(dataCells);\r\n\r\n                const cells = this.state.cells.slice();\r\n                //reset \"t\" cell back to clear\r\n                if(currentCell.status !== \"s\")\r\n                    cells[currentCell.position] = \"c\";\r\n                \r\n                this.setState({cells: cells,\r\n                                inProgress: false});\r\n\r\n\r\n                return;\r\n            }\r\n\r\n            if(this.state.showExtraAnimations){\r\n                await this.animateClosedList(visitedCells);\r\n            }\r\n            \r\n            //console.log(response);\r\n            //console.log(\"smiles first >:(\");\r\n\r\n            //printprojectpath\r\n            this.debugProjectedPath(dataCells, currentCell, \"f\");\r\n            //animateprojectedpath\r\n\r\n\r\n            var pointer = dataCells[this.state.goalLocation];\r\n            var upTo = currentCell;\r\n            var path = [];\r\n            var pt = 0;\r\n            //calculate path for one iteration\r\n            //uncomment to include start position in projected path\r\n            //path[pt] = currentCell;\r\n            //pt++;\r\n            while(upTo !== dataCells[this.state.goalLocation]){\r\n                while(pointer.treePointer !== upTo){\r\n                    pointer = pointer.treePointer;\r\n                }\r\n                //also pointer status to p here\r\n                path[pt] = pointer;\r\n                pt++;\r\n\r\n                upTo = pointer;\r\n                pointer = dataCells[this.state.goalLocation];\r\n            }\r\n\r\n\r\n\r\n            if(this.state.showExtraAnimations){\r\n              await this.animateProjectedPath(path);\r\n            }\r\n            else{\r\n                this.showProjectedPath(path);\r\n            }\r\n\r\n            //console.log(\"wait success\");\r\n\r\n            //display blocked memory\r\n            /*\r\n            for(let i=0; i<mazeSize; i++){\r\n                console.log(\"blocked \" + i + \": \" + blockedMemory[i]);\r\n            }*/\r\n\r\n\r\n            path = [];\r\n            pt = 0;\r\n            pointer = dataCells[this.state.goalLocation];\r\n            //console.log(pointer.status);\r\n            //console.log(pointer.position);\r\n            //console.log(pointer.treePointer);\r\n\r\n            //add current cell position to path\r\n            path[pt] = currentCell;\r\n            pt++;\r\n    \r\n            //traverse path of tree pointers until goal or wall\r\n            while(currentCell !== dataCells[this.state.goalLocation]){\r\n                if(pointer.treePointer === currentCell){\r\n                    //check if wall hit\r\n                    if(pointer.status === \"w\" || pointer.status === \"ws\" || pointer.status === \"clw\" || pointer.status === \"ppw\"){\r\n                        break;\r\n                    }\r\n                    currentCell = pointer;\r\n                    //console.log(\"agent moved to \" + currentCell.position);\r\n    \r\n                    //keep track of total final path\r\n                    finalPathTaken[finalpt] = pointer;\r\n                    finalpt++;\r\n\r\n                    //keep track of this iteration\r\n                    path[pt] = pointer;\r\n                    pt++;\r\n    \r\n                    pointer = dataCells[this.state.goalLocation];\r\n    \r\n                    //check new neighbors for blocked status\r\n                    this.checkNeighbors(dataCells, currentCell);\r\n                }\r\n                else\r\n                    pointer = pointer.treePointer;\r\n            }\r\n        \r\n\r\n            await this.animateTraversal(path);\r\n            \r\n            this.resetBoardStates(dataCells, visitedCells);\r\n\r\n            //countExpanded(newCList);\r\n            /*for(let i=0; i<mazeSize; i++){\r\n                console.log(\"position: \" + dataCells[i].position + \" h: \" + dataCells[i].hVal + \" g: \" + dataCells[i].gVal + \" f: \" + dataCells[i].fVal);\r\n            }*/\r\n            \r\n        }\r\n\r\n\r\n\r\n        console.log(\"goal reached at \" + currentCell.position);\r\n        console.log(\"final path taken: \");\r\n        for(let i = 0; i< finalpt; i++){\r\n            console.log(\"{\" + finalPathTaken[i].status + \" \" + finalPathTaken[i].position + \"} \");\r\n        }\r\n\r\n        //animate final path, update to prepare for next maze\r\n        this.updateWalls(dataCells);\r\n        await this.animateFinalPath(finalPathTaken);\r\n        this.state.goalLocation = null;\r\n        this.setState({inProgress: false});\r\n    }\r\n\r\n    handleFasClick(){\r\n        if(this.state.inProgress){\r\n            return;\r\n        }\r\n        if(this.state.startLocation === null || this.state.goalLocation === null){\r\n            alert(\"must have a start and goal\");\r\n            return;\r\n        }        \r\n        this.setState({inProgress: true});\r\n        previousMaze = this.state.cells;\r\n        previousStart = this.state.startLocation;\r\n        previousGoal = this.state.goalLocation;\r\n        var dataCells = [];\r\n        this.establishMaze(\"f\", dataCells);\r\n        var oList = new PriorityQueue();\r\n        oList.enqueue(dataCells[this.state.startLocation], dataCells[this.state.startLocation].fVal);\r\n        this.forwardAStar(oList, dataCells);\r\n    }\r\n\r\n    handleResetClick(){\r\n        if(this.state.inProgress){\r\n            return;\r\n        }\r\n        this.setState({cells: previousMaze,\r\n                        startLocation: previousStart,\r\n                        goalLocation: previousGoal});\r\n    }\r\n\r\n\r\n    //renders a single cell (at index i) in the maze\r\n    renderCell(i){\r\n        return( \r\n            <Cell \r\n                value = {this.state.cells[i]}\r\n                onMouseDown = {() => this.handleMouseDown(i)}\r\n                onMouseEnter = {() => this.handleMouseEnter(i)}\r\n                onMouseUp = {() => this.handleMouseUp(i)}/>\r\n            );\r\n    }\r\n    \r\n    render() {\r\n        var maze = [];\r\n        for(let i=0; i<numRows; i++){\r\n            var row = [];\r\n            for(let j=0; j<numColumns; j++){\r\n                row.push(\r\n                    <div key={i*numColumns+j} className=\"cell\">\r\n                        {this.renderCell(i*numColumns+j)}\r\n                    </div>\r\n                );\r\n            }\r\n            maze.push(\r\n                <div key={\"row\"+i}className = \"row\">\r\n                    {row}\r\n                </div>\r\n            );\r\n        }\r\n\r\n        return (\r\n            //renders menu buttons\r\n            //renders mazeSize cells in 5 rows of 5\r\n            <div>\r\n                <div className=\"menu\">\r\n                    <button \r\n                        className=\"start-button\"\r\n                        onClick={() => this.handleButtonClick(\"s\")}\r\n                        >place start</button>\r\n                    <button \r\n                        className=\"goal-button\"\r\n                        onClick={() => this.handleButtonClick(\"g\")}\r\n                        >place goal</button>\r\n                    <button \r\n                        className=\"wall-button\"\r\n                        onClick={() => this.handleButtonClick(\"w\")}\r\n                        >place wall</button>\r\n                    <button \r\n                        className=\"clear-button\"\r\n                        onClick={() => this.handleButtonClick(\"c\")}\r\n                        >clear cell</button>\r\n                    <button\r\n                        className=\"randomize\"\r\n                        onClick={() => this.handleRandomizeClick()}\r\n                        >randomize maze</button>\r\n                    <button\r\n                        className=\"clear\"\r\n                        onClick={() => this.handleClearClick()}\r\n                        >clear maze</button>\r\n                    <button\r\n                        className=\"ToggleAnimations\"\r\n                        onClick={() => this.handleAnimationsClick()}\r\n                        >Toggle Extra Animations</button>\r\n                        \r\n                </div>\r\n                <div className = \"maze\">\r\n                    {maze}\r\n                </div>\r\n                <div className = \"debug\">\r\n                    <button \r\n                    className=\"debug\"\r\n                    onClick={() => this.handleDebugClick()}>debug</button>\r\n                </div>\r\n                <div className=\"fas\">\r\n                    <button className=\"fas\"\r\n                    onClick={() => this.handleFasClick()}>fas</button>\r\n                </div>\r\n                <div className=\"reset\">\r\n                    <button\r\n                        className=\"reset\"\r\n                        onClick={() => this.handleResetClick()}>reset</button>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n","import React, {Component} from 'react';\r\n//import Cell from './Cell/Cell';\r\nimport Maze from './Maze/Maze';\r\nimport './MazeSolver.css';\r\n//import PriorityQueue from './PriorityQueue';\r\n\r\nexport default class MazeSolver extends Component{\r\n    \r\n    constructor(props){\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            \r\n            <div>\r\n                \r\n                <div className=\"maze\">\r\n                    <Maze />\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}","import React from 'react';\nimport './App.css';\nimport MazeSolver from './MazeSolver/MazeSolver';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <MazeSolver></MazeSolver>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}